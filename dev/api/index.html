<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Ripserer.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Ripserer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Ripserer.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../generated/basics/">Usage Guide</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Ripserer"><span>Ripserer</span></a></li><li><a class="tocitem" href="#Filtrations"><span>Filtrations</span></a></li><li><a class="tocitem" href="#Persistence-Diagrams"><span>Persistence Diagrams</span></a></li><li><a class="tocitem" href="#Simplices-and-Representatives"><span>Simplices and Representatives</span></a></li><li><a class="tocitem" href="#MLJ.jl-Interface"><span>MLJ.jl Interface</span></a></li><li><a class="tocitem" href="#Experimental-Features"><span>Experimental Features</span></a></li><li><a class="tocitem" href="#Abstract-Types-and-Interfaces"><span>Abstract Types and Interfaces</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/stability/">Stability</a></li><li><a class="tocitem" href="../generated/cocycles/">Cohomology, Homology, and Representatives</a></li><li><a class="tocitem" href="../generated/cubical/">Cubical Persistent Homology</a></li><li><a class="tocitem" href="../generated/malaria/">Image Classification With Cubical Persistent Homology</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../related-work/">Related Julia Packages</a></li><li><a class="tocitem" href="../references/">Acknowledgements and References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Ripserer"><a class="docs-heading-anchor" href="#Ripserer">Ripserer</a><a id="Ripserer-1"></a><a class="docs-heading-anchor-permalink" href="#Ripserer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.ripserer" href="#Ripserer.ripserer"><code>Ripserer.ripserer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ripserer(Type{&lt;:AbstractFiltration}, args...; kwargs...)
ripserer(filtration::AbstractFiltration; kwargs...)</code></pre><p>Compute the persistent homology of a filtration. The filtration can be given as an <a href="#Ripserer.AbstractFiltration"><code>AbstractFiltration</code></a> type, followed by its arguments, or as an initialized object (see examples below). If only data is given, <code>Rips</code> is used by default.</p><p>Returns a <code>Vector</code> of <a href="#PersistenceDiagrams.PersistenceDiagram"><code>PersistenceDiagram</code></a>s with (<code>dim_max</code> + 1) elements. The diagrams are sorted by dimension; the first element of the result is the 0-dimensional diagram, and the last is the (<code>dim_max</code>)-dimensional diagram.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>dim_max</code>: compute persistent homology up to this dimension. Defaults to <code>1</code>.</p></li><li><p><code>modulus</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>. Defaults to <code>2</code>.</p></li><li><p><code>field</code>: use this type of field of coefficients. Defaults to <a href="#Ripserer.Mod"><code>Ripserer.Mod</code></a><code>{modulus}</code>.</p></li><li><p><code>threshold</code>: compute persistent homology up to diameter smaller than threshold. Note that this parameter is passed to the filtration constructor. When using low thresholds with Rips filtrations, consider setting <code>sparse=true</code> for optimal performance.</p></li><li><p><code>cutoff</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>. Defaults to <code>0</code>. When <code>cutoff &lt; 0</code>, the result will also contain zero-length intervals.</p></li><li><p><code>reps</code>: if <code>true</code>, attach representative (co)cycles to persistence intervals. Can also be set to collection of integers to only find representatives in specified dimensions, e.g. <code>reps=1:2</code> will only find representatives in dimensions 1 and 2. This is useful for large filtrations (such as cubical) where calculating zero-dimensional representatives can be very slow. Defaults to <code>false</code> for cohomology and <code>1:dim_max</code> for homology. Representatives are wrapped in a <a href="#Ripserer.Chain"><code>Chain</code></a>.</p></li><li><p><code>verbose</code>: If <code>true</code>, show a verbose bar. Defaults to <code>false</code>.</p></li><li><p><code>alg</code>: select the algorithm used in computation. The options are:</p><ul><li><p><code>:cohomology</code>: Default and fastest algorithm. When <code>reps</code> is set, intervals are equipped with representative <em>co</em>cycles.</p></li><li><p><code>:homology</code>: Significantly slower than <code>:cohomology</code>, but finds representative cycles. Does not find infinite intervals beyond dimension 0.</p></li><li><p><code>:involuted</code>: Use cohomology result to compute representative cycles. Can be extremely efficient compared to <code>:homology</code>, especially with <code>Rips</code> filtrations. See <a href="https://arxiv.org/abs/2105.03629">this paper</a> for more information.</p></li></ul></li><li><p><code>implicit</code>: If <code>true</code>, an implicit reduction algorithm is used. Defaults to <code>true</code> for :cohomology and <code>:involuted</code>, and <code>false</code> for <code>:homology</code>. <code>implicit=false</code> is not recommended for <code>:cohomology</code> because it disables the emergent pairs optimization.</p></li></ul><p>Other <code>kwargs...</code> are passed to the filtration.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ts = range(0, 2π; length=20)[1:(end - 1)];

julia&gt; X = [((2 + cos(θ)) * cos(φ), (2 + cos(θ)) * sin(φ), sin(θ)) for θ in ts for φ in ts];

julia&gt; ripserer(X)
2-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(EdgeCollapsedRips, X; modulus=7, threshold=2)
2-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(Rips(X; threshold=1); alg=:involuted)
2-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 361-element 0-dimensional PersistenceDiagram
 362-element 1-dimensional PersistenceDiagram
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/computation/ripserer.jl#L37-L117">source</a></section></article><h2 id="Filtrations"><a class="docs-heading-anchor" href="#Filtrations">Filtrations</a><a id="Filtrations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtrations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Rips" href="#Ripserer.Rips"><code>Ripserer.Rips</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rips{I, T} &lt;: AbstractRipsFiltration{I, T}</code></pre><p>This type represents a filtration of Vietoris-Rips complexes.</p><p>Diagonal items in the input matrix are treated as vertex birth times.</p><p>Zero values are not allowed due to how sparse matrices work in Julia. If you need zero birth times, try offseting all values by a constant.</p><p>Threshold defaults to the radius of the input space. When using low <code>threshold</code>s, consider using the <code>sparse=true</code> keyword argument. It will give the same result, but may be much faster.</p><p><strong>Constructors</strong></p><ul><li><code>Rips(distance_matrix; threshold=nothing)</code></li><li><code>Rips(points; metric=Euclidean(1e-12), threshold=nothing)</code></li><li><code>Rips{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)][1:end-1];

julia&gt; ripserer(Rips(data))
2-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 100-element 0-dimensional PersistenceDiagram
 1-element 1-dimensional PersistenceDiagram

julia&gt; ripserer(Rips(data, threshold=1.7))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0628, ∞)

julia&gt; using Distances

julia&gt; ripserer(Rips(data, metric=Cityblock()))[2]
1-element 1-dimensional PersistenceDiagram:
 [0.0888, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/rips.jl#L162-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cubical" href="#Ripserer.Cubical"><code>Ripserer.Cubical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cubical{T, K} &lt;: AbstractFiltration{CartesianIndex{K}, T}</code></pre><p><code>Cubical</code> is used to compute sublevel persistent homology on <code>N</code>-dimensional images, which are of type <code>AbstractArray{T, N}</code>.</p><p>This type uses the CubeMap structure to find birth times of cubes (see reference).</p><p><strong>Constructor</strong></p><ul><li><code>Cubical(image::AbstractArray{T, N}, threshold=maximum(image))</code></li></ul><p><strong>Reference</strong></p><p>Wagner, H., Chen, C., &amp; Vuçini, E. (2012). <a href="https://link.springer.com/chapter/10.1007/978-3-642-23175-9_7">Efficient computation of persistent homology for cubical data.</a> In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; image = [1 0 0; 0 2 0; 0 0 0];

julia&gt; ripserer(Cubical(image))[1]
1-element 0-dimensional PersistenceDiagram:
 [0.0, ∞)

julia&gt; ripserer(Cubical(image))[2]
1-element 1-dimensional PersistenceDiagram:
 [1.0, 2.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/cubical.jl#L121-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Custom" href="#Ripserer.Custom"><code>Ripserer.Custom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Custom{I, T} &lt;: AbstractCustomFiltration{I, T}</code></pre><p>Build a custom filtration by specifying simplices and their birth times.</p><p>The list of simplices is corrected to form a valid filtration; birth times are corrected so a simplex is never born before its faces and missing simplices are added.</p><p>See the examples below for construction. Note how the unlisted 0-simplices were added with birth times equal to the lowest between their cofaces. The order in which simplices are given does not matter.</p><p>To create your own types of custom filtrations, subtype <a href="#Ripserer.AbstractCustomFiltration"><code>AbstractCustomFiltration</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flt = Custom([(1,) =&gt; 0, (4,) =&gt; 0, (1, 2) =&gt; 1, (1, 3) =&gt; 2, (1, 4) =&gt; 3, (2, 3) =&gt; 4, (2, 4) =&gt; 5, (3, 4) =&gt; 6, (1, 2, 3) =&gt; 7, (1, 2, 4) =&gt; 8, (1, 3, 4) =&gt; 9]; threshold=8)
Custom{Int64, Int64}(nv=4)

julia&gt; flt[0] # Can be indexed with dimension to list simplices
4-element Vector{Simplex{0, Int64, Int64}}:
 +Simplex{0}((4,), 0)
 +Simplex{0}((2,), 1)
 +Simplex{0}((3,), 2)
 +Simplex{0}((1,), 0)

julia&gt; ripserer(flt)[1]
2-element 0-dimensional PersistenceDiagram:
 [0.0, 3.0)
 [0.0, ∞)

julia&gt; ripserer(flt)[2]
3-element 1-dimensional PersistenceDiagram:
 [5.0, 8.0)
 [4.0, 7.0)
 [6.0, ∞)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/custom.jl#L57-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Alpha" href="#Ripserer.Alpha"><code>Ripserer.Alpha</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Alpha{I, P&lt;:SVector} &lt;: AbstractFiltration{I, Float64}</code></pre><p><code>Alpha</code> filtrations are filtrations of the Delaunay complex.</p><p>They have much fewer simplices than <code>Rips</code>, so they are efficient even with large datasets, as long as their dimensionality is low.  What &quot;low&quot; means depends on the data, but this is definitely a good choice for 3D or lower. For high dimensional data, filtration construction may take a long time.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike most implementations, this one uses circumdiameters instead of circumradii. This makes the scale of the results comparable to <code>Rips</code>. If you need radius based values, divide your data or the resulting interval endpoints by 2.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This filtration uses <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>. Please see the installation instructions if constructions cause errors. MiniQhull currently has problems running on Windows. See <a href="https://github.com/gridap/MiniQhull.jl/issues/5">this issue</a> for more info.</p></div></div><p><strong>Constructors</strong></p><ul><li><code>Alpha(points; threshold, verbose)</code>: <code>points</code> should be a vector of <code>Tuple</code>s, <code>SVector</code>s or similar.</li><li><code>Alpha{I}(args...)</code>: <code>I</code> sets the size of integer used to represent simplices. Try using <code>I=Int128</code> if construction complains about overflow.</li></ul><p><strong>Reference</strong></p><p>Edelsbrunner, H. (1993, July). The union of balls and its dual shape. <a href="https://dl.acm.org/doi/abs/10.1145/160985.161139">In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231)</a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [(sin(t), cos(t), (t - π)^2) for t in range(0, 2π, length=101)[1:end-1]];

julia&gt; alpha = Alpha(data)
Alpha{Int64, Float64}(nv=100)

julia&gt; rips = Rips(data)
Rips{Int64, Float64}(nv=100, sparse=false)

julia&gt; length(Ripserer.edges(alpha))
197

julia&gt; length(Ripserer.edges(rips))
3613

julia&gt; sort(ripserer(alpha)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: Ripserer.Simplex{1, Float64, Int64}
 death_simplex: Ripserer.Simplex{2, Float64, Int64}

julia&gt; sort(ripserer(rips)[2], by=persistence)[end]
[0.375, 2.01) with:
 birth_simplex: Ripserer.Simplex{1, Float64, Int64}
 death_simplex: Ripserer.Simplex{2, Float64, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/alpha.jl#L130-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.EdgeCollapsedRips" href="#Ripserer.EdgeCollapsedRips"><code>Ripserer.EdgeCollapsedRips</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EdgeCollapsedRips{I, T} &lt;: AbstractRipsFiltration{I, T}</code></pre><p>Perform a sequence of edge collapses on a filtration. This may significantly reduce computation time and does not change the result. The speedup is especially apparent with datasets that have a boundary, and with high-dimensional persistent homology computation.</p><p>The drawback is that doing the collapses themselves can be time-consuming. The construction does not require a lot of memory (<span>$\mathcal{O}(n^2)$</span> for <span>$n$</span> vertices). This might still be a good choice for large inputs if you are willing to wait but don&#39;t have enough memory to compute persistent homology with <code>Rips</code>.</p><p>See the reference below for a description of the algorithm.</p><p><strong>Constructors</strong></p><ul><li><p><code>EdgeCollapsedRips(::AbstractRipsFiltration; verbose=false, threshold=nothing )</code>: Collapse a given filtration. Setting <code>verbose</code> shows a progress bar.</p></li><li><p><code>EdgeCollapsedRips(::EdgeCollapsedRips; verbose=false, threshold=nothing)</code>: Allows changing <code>I</code> or <code>threshold</code> without recomputing.</p></li><li><p><code>EdgeCollapsedRips(arg; kwargs...)</code>: Use <code>arg</code> and <code>kwargs</code> to construct a <code>Rips</code> filtration and collapse it</p></li><li><p><code>EdgeCollapsedRips{I}(arg; kwargs...)</code>: Change the index type used to represent simplices. May be necessary for large inputs and high-dimensional computation.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random; Random.seed!(1337);

julia&gt; data = [tuple(rand(6)...) for _ in 1:100];

julia&gt; rips = Rips(data)
Rips{Int64, Float64}(nv=100, sparse=false)

julia&gt; length(Ripserer.edges(rips))
3934

julia&gt; collapsed = EdgeCollapsedRips(data) # or EdgeCollapsedRips(rips)
EdgeCollapsedRips{Int64, Float64}(nv=100)

julia&gt; length(Ripserer.edges(collapsed))
1324

julia&gt; ripserer(rips) == ripserer(collapsed)
true

julia&gt; ripserer(collapsed; dim_max=4)
5-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 100-element 0-dimensional PersistenceDiagram
 58-element 1-dimensional PersistenceDiagram
 35-element 2-dimensional PersistenceDiagram
 10-element 3-dimensional PersistenceDiagram
 4-element 4-dimensional PersistenceDiagram
</code></pre><p><strong>Reference</strong></p><p>Boissonnat, J. D., &amp; Pritam, S. (2019). <a href="https://hal.inria.fr/hal-02395227/">Edge Collapse and Persistence of Flag Complexes</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/edgecollapse.jl#L128-L192">source</a></section></article><h2 id="Persistence-Diagrams"><a class="docs-heading-anchor" href="#Persistence-Diagrams">Persistence Diagrams</a><a id="Persistence-Diagrams-1"></a><a class="docs-heading-anchor-permalink" href="#Persistence-Diagrams" title="Permalink"></a></h2><p>Persistence diagrams live in a separate package, <a href="https://github.com/mtsch/PersistenceDiagrams.jl">PersistenceDiagrams.jl</a>. The package is documented in detail <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/">here</a>.</p><p>If you are looking for Wasserstein or bottleneck distances, persistence images, betti curves, landscapes, and similar, you will need to run <code>using PersistenceDiagrams</code>.</p><p>For convenience, the following basic functionality is reexported by Ripserer:</p><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.PersistenceDiagram" href="#PersistenceDiagrams.PersistenceDiagram"><code>PersistenceDiagrams.PersistenceDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PersistenceDiagram &lt;: AbstractVector{PersistenceInterval}</code></pre><p>Type for representing persistence diagrams. Behaves exactly like a vector of <code>PersistenceInterval</code>s, but can have additional metadata attached to it. It supports pretty printing and plotting.</p><p>Can be used as a table with any function that uses the <a href="https://github.com/JuliaData/Tables.jl"><code>Tables.jl</code></a> interface. Note that using it as a table will only keep interval endpoints and the <code>dim</code> and <code>threshold</code> attributes.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; diagram = PersistenceDiagram([(1, 3), (3, 4), (1, Inf)]; dim=1, custom_metadata=:a)
3-element 1-dimensional PersistenceDiagram:
 [1.0, 3.0)
 [3.0, 4.0)
 [1.0, ∞)

julia&gt; diagram[1]
[1.0, 3.0)

julia&gt; sort(diagram; by=persistence, rev=true)
3-element 1-dimensional PersistenceDiagram:
 [1.0, ∞)
 [1.0, 3.0)
 [3.0, 4.0)

julia&gt; propertynames(diagram)
(:intervals, :dim, :custom_metadata)

julia&gt; dim(diagram)
1

julia&gt; diagram.custom_metadata
:a</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.PersistenceInterval" href="#PersistenceDiagrams.PersistenceInterval"><code>PersistenceDiagrams.PersistenceInterval</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PersistenceInterval</code></pre><p>Type for representing persistence intervals. It behaves exactly like a <code>Tuple{Float64, Float64}</code>, but can have meta data attached to it. The metadata is accessible with <code>getproperty</code> or the dot syntax.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; interval = PersistenceInterval(1, Inf; meta1=:a, meta2=:b)
[1.0, ∞) with:
 meta1: Symbol
 meta2: Symbol

julia&gt; birth(interval), death(interval), persistence(interval)
(1.0, Inf, Inf)

julia&gt; isfinite(interval)
false

julia&gt; propertynames(interval)
(:birth, :death, :meta1, :meta2)

julia&gt; interval.meta1
:a</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.birth-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">birth(interval)</code></pre><p>Get the birth time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.death-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.death-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.death</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">death(interval)</code></pre><p>Get the death time of <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.persistence-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.persistence-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.persistence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">persistence(interval)</code></pre><p>Get the persistence of <code>interval</code>, which is equal to <code>death - birth</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.midlife" href="#PersistenceDiagrams.midlife"><code>PersistenceDiagrams.midlife</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">midlife(interval)</code></pre><p>Get the midlife of the <code>interval</code>, which is equal to <code>(birth + death) / 2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.representative-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.representative-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.representative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representative(interval::PersistenceInterval)</code></pre><p>Get the representative (co)cycle attached to <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.birth_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">birth_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical birth simplex of <code>interval</code>, if it has one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}" href="#PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}"><code>PersistenceDiagrams.death_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">death_simplex(interval::PersistenceInterval)</code></pre><p>Get the critical death simplex of <code>interval</code>, if it has one.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>An infinite interval&#39;s death simplex is <code>nothing</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.barcode" href="#PersistenceDiagrams.barcode"><code>PersistenceDiagrams.barcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barcode(diagram)</code></pre><p>Plot the barcode plot of persistence diagram or multiple diagrams in a collection. The <code>infinity</code> keyword argument determines where the infinity line is placed. If unset, the function tries to use <code>threshold(diagram)</code>, or guess a good position to place the line at.</p></div></section></article><h2 id="Simplices-and-Representatives"><a class="docs-heading-anchor" href="#Simplices-and-Representatives">Simplices and Representatives</a><a id="Simplices-and-Representatives-1"></a><a class="docs-heading-anchor-permalink" href="#Simplices-and-Representatives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Simplex" href="#Ripserer.Simplex"><code>Ripserer.Simplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simplex{D, T, I&lt;:Integer} &lt;: AbstractSimplex{D, T, I}</code></pre><p>The vanilla simplex type represented by dimension <code>D</code>, an index of type <code>I</code>, and a birth time of type <code>T</code>.</p><p><strong>Constructors</strong></p><ul><li><code>Simplex{D[, T, I]}(index, birth)</code></li><li><code>Simplex{D}(vertices, birth)</code>: vertices must be sorted descending. This constructor mainly exists for debugging purposes. Using <a href="#Ripserer.simplex"><code>simplex</code></a> is usually the better option.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sx = Simplex{2}(2, 1)
2-dimensional Simplex(index=2, birth=1):
  +(4, 2, 1)

julia&gt; index(sx)
2

julia&gt; vertices(sx)
(4, 2, 1)

julia&gt; birth(sx)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/simplex.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Cube" href="#Ripserer.Cube"><code>Ripserer.Cube</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cube{D, T, K} &lt;: AbstractCell{D, T, CartesianIndex{K}}</code></pre><p>A <code>Cube</code> is similar to a <code>Simplex</code>, but it has <code>2^D</code> vertices instead of <code>D+1</code>. The vertices are encoded as the position in the CubeMap (see reference in <a href="#Ripserer.Cubical"><code>Cubical</code></a>). A <code>Cube</code>&#39;s vertices are of type <code>CartesianIndex{K}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Cube{1}(CartesianIndex(1, 2), 1.0)
Cube{1, Float64, 2}((1, 2), 1.0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/cubical.jl#L78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.dim-Tuple{Ripserer.AbstractCell}" href="#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractCell}"><code>PersistenceDiagrams.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(::AbstractCell)
dim(::Type{&lt;:AbstractCell})</code></pre><p>Get the dimension of a cell i.e. the value of <code>D</code>. Can also be called on the type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dim(Simplex{2}((3, 2, 1), 3.2))
2

julia&gt; dim(Cube{3, Int, 4})
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.birth-Tuple{Ripserer.AbstractCell}" href="#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractCell}"><code>PersistenceDiagrams.birth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">birth(σ::AbstractCell)</code></pre><p>Get the birth time of <code>σ</code>, i.e. the time it first appears in the filtration.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; birth(Simplex{2}((3, 2, 1), 3.2))
3.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L75-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.index-Tuple{Ripserer.AbstractCell}" href="#Ripserer.index-Tuple{Ripserer.AbstractCell}"><code>Ripserer.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index(σ::AbstractCell)</code></pre><p>Get the combinatorial index of the <code>σ</code>. The index can be any type, but should uniquely identify a cell. It is also used to break ties when comparing simplices with the same birth time.</p><pre><code class="language-julia-repl hljs">julia&gt; index(Simplex{2}((3, 2, 1), 3.2))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{Ripserer.AbstractCell}" href="#Graphs.vertices-Tuple{Ripserer.AbstractCell}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(σ::AbstractCell{D,T,I})::NTuple{length(σ),I}</code></pre><p>Get the vertices of <code>σ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vertices(Simplex{2}((3, 2, 1), 3.2))
(3, 2, 1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L89-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Chain" href="#Ripserer.Chain"><code>Ripserer.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chain{F,S,E} &lt;: AbstractVector{ChainElement{S,F}}</code></pre><p>An internal representation of a chain. Behaves like an array of pairs <code>S =&gt; F</code>, where <code>S</code> is the simplex type, and <code>F</code> is the coefficient type (probably a subtype of <a href="#Ripserer.Mod"><code>Mod</code></a>).</p><p>Most functions that can be called on <code>AbstractCell</code>s can also be called on the elements of a <code>Chain</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [(rand(), rand(), rand()) for _ in 1:100];

julia&gt; result = ripserer(data; reps=true, modulus=7);

julia&gt; chain = result[end][end].representative
28-element Chain{Ripserer.Mod{7},Ripserer.Simplex{1, Float64, Int64}}:
 +Simplex{1}((68, 54), 0.25178097927369875) =&gt; 6 mod 7
 +Simplex{1}((54, 46), 0.2575262844682746) =&gt; 1 mod 7
 +Simplex{1}((88, 56), 0.25936896586973557) =&gt; 1 mod 7
 +Simplex{1}((79, 22), 0.26690101517910964) =&gt; 6 mod 7
 +Simplex{1}((53, 13), 0.27161939814693414) =&gt; 6 mod 7
 +Simplex{1}((24, 13), 0.28686687771884056) =&gt; 6 mod 7
 +Simplex{1}((56, 54), 0.2869400047523196) =&gt; 6 mod 7
 +Simplex{1}((50, 42), 0.29274772369750884) =&gt; 6 mod 7
 +Simplex{1}((93, 50), 0.3022995886824861) =&gt; 1 mod 7
 +Simplex{1}((73, 54), 0.30771273548368216) =&gt; 6 mod 7
 ⋮
 +Simplex{1}((70, 34), 0.3412250751087395) =&gt; 6 mod 7
 +Simplex{1}((49, 42), 0.3414959312908324) =&gt; 6 mod 7
 +Simplex{1}((49, 7), 0.35568373080560794) =&gt; 6 mod 7
 +Simplex{1}((88, 46), 0.35629002982624475) =&gt; 1 mod 7
 +Simplex{1}((95, 88), 0.3566986102316938) =&gt; 6 mod 7
 +Simplex{1}((95, 54), 0.363029725360828) =&gt; 6 mod 7
 +Simplex{1}((50, 13), 0.3648936036309352) =&gt; 6 mod 7
 +Simplex{1}((24, 3), 0.3653704317993549) =&gt; 6 mod 7
 +Simplex{1}((85, 42), 0.369953146904745) =&gt; 6 mod 7

julia&gt; simplex.(chain)
28-element Vector{Simplex{1, Float64, Int64}}:
 +Simplex{1}((68, 54), 0.25178097927369875)
 +Simplex{1}((54, 46), 0.2575262844682746)
 +Simplex{1}((88, 56), 0.25936896586973557)
 +Simplex{1}((79, 22), 0.26690101517910964)
 +Simplex{1}((53, 13), 0.27161939814693414)
 +Simplex{1}((24, 13), 0.28686687771884056)
 +Simplex{1}((56, 54), 0.2869400047523196)
 +Simplex{1}((50, 42), 0.29274772369750884)
 +Simplex{1}((93, 50), 0.3022995886824861)
 +Simplex{1}((73, 54), 0.30771273548368216)
 ⋮
 +Simplex{1}((70, 34), 0.3412250751087395)
 +Simplex{1}((49, 42), 0.3414959312908324)
 +Simplex{1}((49, 7), 0.35568373080560794)
 +Simplex{1}((88, 46), 0.35629002982624475)
 +Simplex{1}((95, 88), 0.3566986102316938)
 +Simplex{1}((95, 54), 0.363029725360828)
 +Simplex{1}((50, 13), 0.3648936036309352)
 +Simplex{1}((24, 3), 0.3653704317993549)
 +Simplex{1}((85, 42), 0.369953146904745)

julia&gt; vertices.(chain)
28-element Vector{Tuple{Int64, Int64}}:
 (68, 54)
 (54, 46)
 (88, 56)
 (79, 22)
 (53, 13)
 (24, 13)
 (56, 54)
 (50, 42)
 (93, 50)
 (73, 54)
 ⋮
 (70, 34)
 (49, 42)
 (49, 7)
 (88, 46)
 (95, 88)
 (95, 54)
 (50, 13)
 (24, 3)
 (85, 42)

julia&gt; coefficient.(chain)
28-element Vector{Mod{7}}:
 6 mod 7
 1 mod 7
 1 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
 1 mod 7
 6 mod 7
       ⋮
 6 mod 7
 6 mod 7
 6 mod 7
 1 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
 6 mod 7
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/chain.jl#L8-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Mod" href="#Ripserer.Mod"><code>Ripserer.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mod{M} &lt;: Integer</code></pre><p><code>Mod{M}</code> is the default field used by Ripserer. It is a representation of a finite field <span>$\mathbb{Z}_M$</span>, integers modulo small, prime <code>M</code>. Supports field arithmetic and can be converted to integer with <code>Int</code>.</p><p>Its values are not comparable on purpose.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Mod{3}(5)
2 mod 3

julia&gt; Mod{3}(5) + 1
0 mod 3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/primefield.jl#L36-L55">source</a></section></article><h2 id="MLJ.jl-Interface"><a class="docs-heading-anchor" href="#MLJ.jl-Interface">MLJ.jl Interface</a><a id="MLJ.jl-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#MLJ.jl-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.RipsPersistentHomology" href="#Ripserer.RipsPersistentHomology"><code>Ripserer.RipsPersistentHomology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RipsPersistentHomology</code></pre><p>Compute Vietoris-Rips persistent homology and convert the results to a table of continuous values.</p><p>!!! warning Warning     Computing Vietoris-Rips persistent homology may be CPU and memory intensive even for     modestly-sized data sets. Consider using <a href="#Ripserer.AlphaPersistentHomology"><code>AlphaPersistentHomology</code></a> for     low-dimensional data.</p><p><strong>Hyperparameters</strong></p><ul><li><p><code>vectorizer = PersistenceImageVectorizer()</code>: <code>AbstractVectorizer</code> used to transform persistence diagrams to continuous vectors. See the <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/mlj/">PersistenceDiagrams.jl Documentation</a> for more information.</p></li><li><p><code>dim_max = 1</code>: compute persistent homology up to this dimension.</p></li><li><p><code>modulus = 2</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>.</p></li><li><p><code>threshold = nothing</code>: compute persistent homology up to diameter smaller than threshold.</p></li><li><p><code>cutoff = 0</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>.</p></li><li><p><code>sparse = false</code>: use a sparse Rips filtration.</p></li><li><p><code>collapse = false</code>: use the <a href="#Ripserer.EdgeCollapsedRips"><code>EdgeCollapsedRips</code></a> filtration. This is usually a good choice for computations with a high <code>dim_max</code>.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#Ripserer.ripserer"><code>ripserer</code></a></li><li><a href="#Ripserer.Rips"><code>Rips</code></a></li><li><a href="#Ripserer.EdgeCollapsedRips"><code>EdgeCollapsedRips</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/mlj.jl#L39-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AlphaPersistentHomology" href="#Ripserer.AlphaPersistentHomology"><code>Ripserer.AlphaPersistentHomology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AlphaPersistentHomology</code></pre><p>Compute alpha complex persistent homology and convert the results to a table of continuous values.</p><p>!!! warning Warning     Using high-dimensional data with this model may be computationaly expensive. Consider     using <a href="#Ripserer.RipsPersistentHomology"><code>RipsPersistentHomology</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This model uses <a href="https://github.com/gridap/MiniQhull.jl">MiniQhull.jl</a>. Please see the installation instructions if fitting causes errors. MiniQhull currently has problems running on Windows. See <a href="https://github.com/gridap/MiniQhull.jl/issues/5">this issue</a> for more info.</p></div></div><p><strong>Hyperparameters</strong></p><ul><li><p><code>vectorizer = PersistenceImageVectorizer()</code>: <code>AbstractVectorizer</code> used to transform persistence diagrams to continuous vectors. See the <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/mlj/">PersistenceDiagrams.jl Documentation</a> for more information.</p></li><li><p><code>dim_max = 1</code>: compute persistent homology up to this dimension.</p></li><li><p><code>modulus = 2</code>: compute persistent homology with coefficients in the prime field of integers mod <code>modulus</code>.</p></li><li><p><code>threshold = nothing</code>: compute persistent homology up to diameter smaller than threshold.</p></li><li><p><code>cutoff = 0</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#Ripserer.ripserer"><code>ripserer</code></a></li><li><a href="#Ripserer.Alpha"><code>Alpha</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/mlj.jl#L114-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.CubicalPersistentHomology" href="#Ripserer.CubicalPersistentHomology"><code>Ripserer.CubicalPersistentHomology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CubicalPersistentHomology</code></pre><p>Compute cubical persistent homology and convert the results to a table of continuous values.</p><p><strong>Hyperparameters</strong></p><ul><li><p><code>vectorizer = PersistenceImageVectorizer()</code>: <code>AbstractVectorizer</code> used to transform persistence diagrams to continuous vectors. See the <a href="https://mtsch.github.io/PersistenceDiagrams.jl/dev/mlj/">PersistenceDiagrams.jl Documentation</a> for more information.</p></li><li><p><code>dim_max = 1</code>: compute persistent homology up to this dimension.</p></li><li><p><code>threshold = nothing</code>: compute persistent homology up to diameter smaller than threshold.</p></li><li><p><code>cutoff = 0</code>: only keep intervals with <code>persistence(interval) &gt; cutoff</code>.</p></li><li><p><code>negate = false</code>: negate the image before computation.</p></li></ul><p><strong>See also</strong></p><ul><li><a href="#Ripserer.ripserer"><code>ripserer</code></a></li><li><a href="#Ripserer.Cubical"><code>Cubical</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/mlj.jl#L176-L202">source</a></section></article><h2 id="Experimental-Features"><a class="docs-heading-anchor" href="#Experimental-Features">Experimental Features</a><a id="Experimental-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Experimental-Features" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.reconstruct_cycle" href="#Ripserer.reconstruct_cycle"><code>Ripserer.reconstruct_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reconstruct_cycle(filtration, interval[, t]; distances=distance_matrix(filtration))</code></pre><p>Reconstruct the shortest representative cycle for the first homology group of given <code>interval</code>. The optional argument <code>t</code> sets the time at which the cycle is to be computed. It defaults to interval birth time, which gives a cycle similar to a representative cycle computed from homology. In general, higher times will yield nicer cycles. <code>t</code> can be a simplex or a number.</p><p>The optional <code>distances</code> keyword argument can be used to change the distance matrix used for determining edge lengths.</p><p>This method uses the representative <em>co</em>cycle to compute the cycle. As such, the interval must be computed with the default cohomology algorithm and must include a representative. To get such an interval, run <code>ripserer</code> with the keyword argument <code>reps=true</code> or <code>reps=1</code>.</p><p>Note that this method only works in the first dimension, as it is based on finding shortest paths in a graph.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is still experimental.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/cycles.jl#L133-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.Partition" href="#Ripserer.Partition"><code>Ripserer.Partition</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Partition</code></pre><p>This submodule contains the following partition functions to be used with circular coordinates.</p><ul><li><code>Partition.linear(r, d) = max(r - d, 0.0)</code></li><li><code>Partition.quadratic(r, d) = (max(r - d, 0.0))^2</code></li><li><code>Partition.exponential(r, d) = r - d &gt; 0 ? exp(r^2/(d^2 - r^2)) : 0.0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/circularcoordinates.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.CircularCoordinates" href="#Ripserer.CircularCoordinates"><code>Ripserer.CircularCoordinates</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CircularCoordinates</code></pre><p>This <code>struct</code> implements Perea&#39;s sparse circular coordinates (see reference below).</p><p>The idea behind this method is that you pick a subset of your data set (also called landmarks), compute persistent cohomology on that subset, and use the result to construct circular coordinates on the whole data set.</p><p>For this to work correctly, you need the following.</p><ul><li>A set of landmarks that cover the points well. The default minmax sampling method is</li></ul><p>usually a good choice here.</p><ul><li>The persistence diagram on the landmarks must have an interval that is persistent enough.</li></ul><p>The circular coordinates returned are on the interval [0, 1). If you are looking for angles, make sure to multiply them by <code>2π</code>.</p><p>If you try to compute circular coordinates for a point that is not near any landmark, the result will be <code>missing</code>.</p><p><strong>Constructor</strong></p><p><code>CircularCoordinates([::AbstractFiltration, ]points, landmarks; kwargs...)</code></p><p><strong>Arguments</strong></p><ul><li><p><code>points</code>: a vector of points. The <code>eltype</code> of this vector can be <code>Tuple</code>s, <code>SVector</code>s, or similar.</p></li><li><p><code>landmarks</code>: can be an integer, a vector of indices, or a vector of points. If set to an integer, it sets the number of landmarks to choose with maxmin sampling. If you are looking for non-sparse circular coordinates, use <code>landmarks=eachindex(points)</code>.</p></li><li><p><code>out_dim</code>: number of most persistent persistence intervals to use to compute coordinates. If less than <code>out_dim</code> suitable intervals are found, the construction will show a warning and construct <code>CircularCoordinates</code> with a lower <code>out_dim</code>. This warning can be suppressed by passing <code>warn=false</code>.</p></li><li><p><code>partition</code>: a function that defines the partition of unity used when determining the coordinates. Should take two arguments, <code>r</code>, the radius of the balls, and <code>d</code>, the distance from the landmark. The partition function should only have support on the ball around the landmark (in other words, it should evaluate to 0 when d ≥ r). If that is not the case, the circular coordinates are not well-defined and the results may not always make sense. See <a href="#Ripserer.Partition"><code>Partition</code></a> for a small collection of predefined functions.</p></li><li><p><code>metric</code>: a metric from <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a>. Can only be set if the filtration argument is <code>Rips</code>.</p></li><li><p><code>kwargs...</code>: additional keyword arguments passed to <code>ripserer</code>. Note that <code>modulus</code> is set to a random prime between 7 and 79 by default.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)[1:end-1]];

julia&gt; cc = CircularCoordinates(data, 1:10:100)
CircularCoordinates(
  out_dim=1,
  radius=(0.9510565162951535,),
  n_landmarks=10,
  partition=linear,
  metric=Distances.Euclidean(0.0),
)

julia&gt; summary(cc(data))
&quot;100×1 Matrix{Union{Missing, Float64}}&quot;

julia&gt; summary(cc(data, 1))
&quot;100-element Vector{Union{Missing, Float64}}&quot;
</code></pre><p><strong>Reference</strong></p><p>Perea, J. A. (2020, June). Sparse circular coordinates via principal Z-bundles. In Topological Data Analysis: The Abel Symposium 2018 (Vol. 15, p. 435). Springer Nature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/extra/circularcoordinates.jl#L132-L211">source</a></section></article><h2 id="Abstract-Types-and-Interfaces"><a class="docs-heading-anchor" href="#Abstract-Types-and-Interfaces">Abstract Types and Interfaces</a><a id="Abstract-Types-and-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types-and-Interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractFiltration" href="#Ripserer.AbstractFiltration"><code>Ripserer.AbstractFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFiltration{I,T}</code></pre><p>A filtration is used to find the edges in filtration and to create simplices. An <code>AbstractFiltration{I,T}</code>&#39;s simplex type is expected to return simplices of type <code>&lt;:AbstractCell{_,T,I}</code>.</p><p>An <code>AbstractFiltration</code> constructor must accept the <code>verbose</code> keyword argument.</p><p><strong>Interface</strong></p><ul><li><a href="#Graphs.nv-Tuple{Ripserer.AbstractFiltration}"><code>nv(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.births-Tuple{Ripserer.AbstractFiltration}"><code>births(::AbstractFiltration)</code></a></li><li><a href="#Graphs.vertices-Tuple{Ripserer.AbstractFiltration}"><code>vertices(::AbstractFiltration)</code></a></li><li><a href="#Graphs.edges-Tuple{Ripserer.AbstractFiltration}"><code>edges(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.simplex_type"><code>simplex_type(::Type{AbstractFiltration}, dim)</code></a></li><li><a href="#Ripserer.simplex"><code>simplex(::AbstractFiltration, ::Val{dim}, vertices)</code></a></li><li><a href="#Ripserer.unsafe_simplex"><code>unsafe_simplex(::AbstractFiltration, ::Val{dim}, vertices)</code></a></li><li><a href="#Ripserer.unsafe_cofacet"><code>unsafe_cofacet</code></a><code>(::AbstractFiltration, simplex, vertices, vertex[, edges])</code></li><li><a href="#PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}"><code>threshold(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.columns_to_reduce"><code>columns_to_reduce(::AbstractFiltration, ::Any)</code></a></li><li><a href="#Ripserer.emergent_pairs"><code>emergent_pairs(::AbstractFiltration)</code></a></li><li><a href="#Ripserer.postprocess_diagram"><code>postprocess_diagram(::AbstractFiltration, ::Any)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{Ripserer.AbstractFiltration}" href="#Graphs.nv-Tuple{Ripserer.AbstractFiltration}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nv(::AbstractFiltration)</code></pre><p>Return the number of vertices in <code>filtration</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ripserer.nv(Rips([1 1; 1 1]))
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.births-Tuple{Ripserer.AbstractFiltration}" href="#Ripserer.births-Tuple{Ripserer.AbstractFiltration}"><code>Ripserer.births</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">births(::AbstractFiltration)</code></pre><p>Get the birth times of vertices in filtration. Defaults to all births being 0. Must return array of the same shape as the filtration&#39;s <code>vertices</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flt = Rips([1 1 2; 1 0 1; 2 1 0]);

julia&gt; Ripserer.births(flt)
3-element view(::Vector{Int64}, 1:4:9) with eltype Int64:
 1
 0
 0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L174-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{Ripserer.AbstractFiltration}" href="#Graphs.vertices-Tuple{Ripserer.AbstractFiltration}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(::AbstractFiltration)</code></pre><p>Return the vertices in filtration. Defaults to <code>1:n</code>. The <code>shape</code> and <code>eltype</code> of the result can be anything as long as <code>result[result[i]] == result[i]</code> holds.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vertices(Rips([0 1 1; 1 0 1; 1 1 0]))
Base.OneTo(3)

julia&gt; vertices(Cubical([0 1 1; 1 0 1; 1 1 0]))
3×3 CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L152-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Tuple{Ripserer.AbstractFiltration}" href="#Graphs.edges-Tuple{Ripserer.AbstractFiltration}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edges(::AbstractFiltration)</code></pre><p>Get edges (1-simplices) in <code>filtration</code>. Edges should be of type <a href="#Ripserer.simplex_type"><code>simplex_type</code></a><code>(filtration, 1)</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; Ripserer.edges(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2))
3-element Array{Simplex{1,Int64,Int64},1}:
 +Simplex{1}([2, 1], 2)
 +Simplex{1}([3, 1], 1)
 +Simplex{1}([3, 2], 1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L69-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.simplex_type" href="#Ripserer.simplex_type"><code>Ripserer.simplex_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_type(::Type{&lt;:AbstractFiltration}, D)
simplex_type(::AbstractFiltration, D)</code></pre><p>Return the <code>D</code>-dimensional simplex type in the filtration. Only the method for the type needs to be overloaded.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ripserer.simplex_type(Rips{Int,Float64}, 1)
Simplex{1, Float64, Int64}

julia&gt; Ripserer.simplex_type(Cubical{2,Float16}, 2)
Cube{2, Float16, 2}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L31-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.simplex" href="#Ripserer.simplex"><code>Ripserer.simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> simplex(::AbstractFiltration, ::Val{D}, vertices)</code></pre><p>Return <code>D</code>-simplex constructed from <code>vertices</code>. Return <code>nothing</code> if simplex is not in filtration. This function is safe to call with vertices that are out of order. Default implementation sorts <code>vertices</code> and calls <a href="#Ripserer.unsafe_simplex"><code>unsafe_simplex</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; simplex(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2), Val(1), (1, 2))
1-dimensional Simplex(index=1, birth=2):
  +[2, 1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L88-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.unsafe_simplex" href="#Ripserer.unsafe_simplex"><code>Ripserer.unsafe_simplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_simplex(::AbstractFiltration, ::Val{D}, vertices)</code></pre><p>Return <code>D</code>-simplex constructed from <code>vertices</code>. Return <code>nothing</code> if simplex is not in filtration. The unsafe in the name implies that it&#39;s up to the caller to ensure vertices are sorted and unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.unsafe_cofacet" href="#Ripserer.unsafe_cofacet"><code>Ripserer.unsafe_cofacet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_cofacet(filtration, simplex, cofacet_vertices, v[, edges])
unsafe_cofacet(::Type{S}, filtration, simplex, cofacet_vertices, v[, edges])</code></pre><p>Return cofacet of <code>simplex</code> with vertices equal to <code>cofacet_vertices</code>. <code>v</code> is the vertex that was added to construct the cofacet. In the case of sparse rips filtrations, an additional argument <code>edges</code> is used. <code>edges</code> is a vector that contains the weights on edges connecting the new vertex to old vertices. <code>S</code> is the simplex type which can be used for dispatch.</p><p>The unsafe in the name implies that it&#39;s up to the caller to ensure vertices are sorted and unique.</p><p>Default implementation uses <a href="#Ripserer.unsafe_simplex"><code>unsafe_simplex</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L130-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}" href="#PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}"><code>PersistenceDiagrams.threshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threshold(::AbstractFiltration)</code></pre><p>Get the threshold of filtration. This is the maximum diameter a simplex in the filtration can have. Defaults to <code>Inf</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; threshold(Rips([0 2 1; 2 0 1; 1 1 0]))
1

julia&gt; threshold(Cubical([1 1 2; 3 2 1; 0 0 0]))
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L195-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.columns_to_reduce" href="#Ripserer.columns_to_reduce"><code>Ripserer.columns_to_reduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">columns_to_reduce(::AbstractFilration, prev_column_itr)</code></pre><p>List all columns to reduce in next dimension, possibly computing it from previous columns. Default implementation uses <a href="#Ripserer.coboundary"><code>coboundary</code></a> with the all cofacets parameter set to <code>Val(false)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flt = Rips([0 1 1; 1 0 1; 1 1 0]);

julia&gt; Ripserer.columns_to_reduce(flt, Ripserer.edges(flt)) |&gt; collect
1-element Vector{Simplex{2, Int64, Int64}}:
 +Simplex{2}((3, 2, 1), 1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L246-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.emergent_pairs" href="#Ripserer.emergent_pairs"><code>Ripserer.emergent_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emergent_pairs(::AbstractFiltration)</code></pre><p>Return <code>true</code> if the emergent pairs optimization is to be performed. Default to returning <code>true</code>. Should be set to <code>false</code> for a filtration type that is unable to produce (co)boundary simplices in the correct order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L268-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.postprocess_diagram" href="#Ripserer.postprocess_diagram"><code>Ripserer.postprocess_diagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">postprocess_diagram(::AbstractFiltration, diagram)</code></pre><p>This function is called on each resulting persistence diagram after all intervals have been computed. Defaults to not doing anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.distance_matrix" href="#Ripserer.distance_matrix"><code>Ripserer.distance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance_matrix(::AbstractFiltration)</code></pre><p>Return a matrix with distances between vertices of the filtration. These distances are used to determine edge length when finding shortest represenatative cycle in <a href="#Ripserer.reconstruct_cycle"><code>reconstruct_cycle</code></a>.</p><p>Defaults to all distances being 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flt = Rips([1 1 2; 1 0 1; 2 1 0]);

julia&gt; Ripserer.distance_matrix(flt)
3×3 Matrix{Int64}:
 1  1  2
 1  0  1
 2  1  0

julia&gt; flt = Custom([(1,2,3,4) =&gt; 10.0, (1,2) =&gt; 3.0, (1,3) =&gt; 4.0, (2,3) =&gt; 5.0]);

julia&gt; Ripserer.distance_matrix(flt)
4×4 Ripserer.DefaultDist{Float64}:
 0.0  1.0  1.0  1.0
 1.0  0.0  1.0  1.0
 1.0  1.0  0.0  1.0
 1.0  1.0  1.0  0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L318-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractRipsFiltration" href="#Ripserer.AbstractRipsFiltration"><code>Ripserer.AbstractRipsFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRipsFiltration{I&lt;:Signed, T} &lt;: AbstractFiltration{I, T}</code></pre><p>An abstract Vietoris-Rips filtration. Its subtypes can only overload <a href="#Graphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}"><code>adjacency_matrix</code></a> and get default implementations for the rest of the filtration interface.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyRips &lt;: Ripserer.AbstractRipsFiltration{Int, Float16} end

julia&gt; Ripserer.adjacency_matrix(::MyRips) = [0 1 1; 1 0 1; 1 1 0]

julia&gt; ripserer(MyRips())
2-element Vector{PersistenceDiagrams.PersistenceDiagram}:
 3-element 0-dimensional PersistenceDiagram
 0-element 1-dimensional PersistenceDiagram
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/rips.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}" href="#Graphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}"><code>Graphs.LinAlg.adjacency_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjacency_matrix(::AbstractFiltration)</code></pre><p>Return the adjacency matrix. For sparse filtrations, this should return a <code>SparseMatrixCSC</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ripserer.adjacency_matrix(Rips([0 2 1; 2 0 1; 1 1 0]))
3×3 Matrix{Int64}:
 0  2  1
 2  0  1
 1  1  0

julia&gt; Ripserer.adjacency_matrix(Rips([0 10 2; 10 0 1; 2 1 0]; sparse=true))
3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 ⋅  ⋅  2
 ⋅  ⋅  1
 2  1  ⋅

julia&gt; Ripserer.adjacency_matrix(Custom([(2, 1) =&gt; 1, (5, 1) =&gt; 2, (3, 4) =&gt; 3]))
5×5 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:
 ⋅  1  ⋅  ⋅  1
 1  ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  1  ⋅
 ⋅  ⋅  1  ⋅  ⋅
 1  ⋅  ⋅  ⋅  ⋅
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractfiltration.jl#L214-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractCustomFiltration" href="#Ripserer.AbstractCustomFiltration"><code>Ripserer.AbstractCustomFiltration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCustomFiltration{I, T} &lt;: AbstractFiltration{I, T}</code></pre><p>This abstract type is for filtrations that have all simplices stored in <code>Dict</code>s. The dicts should be accessible by the function <a href="#Ripserer.simplex_dicts"><code>simplex_dicts</code></a> and should be a vector of <code>Dict{I, T}</code>. A custom filtration should also have <a href="#Graphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}"><code>adjacency_matrix</code></a> defined. This matrix is only used as an adjacency matrix. Its values are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/custom.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.simplex_dicts" href="#Ripserer.simplex_dicts"><code>Ripserer.simplex_dicts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplex_dicts(::AbstractCustomFiltration)</code></pre><p>Get the dictionaries used to get simplex birth times. Should return a <code>Vector</code> of <code>Dict{I, T}</code> that maps a simplex index to its birth time. The first element of this <code>Vector</code> corresponds to vertices, second to 1-simplices etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/filtrations/custom.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractCell" href="#Ripserer.AbstractCell"><code>Ripserer.AbstractCell</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCell{D, T, I}</code></pre><p>An abstract type for representing simplices and other types of cells, such as cubes. A cell is determined by the following.</p><ul><li><p>Its dimension encoded in the type parameter <code>D</code>. Can be accessed with <a href="#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractCell}"><code>dim</code></a></p></li><li><p>The <code>index</code> of type <code>I</code> is used to differentiate between different cells. In general, two cells of the same type (and hence dimension) and the same <code>index</code> are considered to be equal.</p></li><li><p>The <code>birth</code> of type <code>T</code> determines when the cell enters the filtration. Note that two cells with the same <code>index</code> should also have the same <code>birth</code>.</p></li><li><p><code>vertices</code> should return the cell&#39;s vertices as a tuple. For 0-cells (vertices), the <code>vertices</code> are also used to index into a filtration&#39;s <a href="vertices(::AbstractFiltration)"><code>vertices</code></a>.</p></li><li><p>The <code>sign</code> determens its orientation. Note that <code>cell == -cell</code>.</p></li></ul><p><strong>Interface</strong></p><ul><li><a href="#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractCell}"><code>birth(::AbstractCell)</code></a>::T</li><li><a href="#Ripserer.index-Tuple{Ripserer.AbstractCell}"><code>index(::AbstractCell)</code></a>::I</li><li><a href="#Graphs.vertices-Tuple{Ripserer.AbstractCell}"><code>vertices(σ::AbstractCell)</code></a>::NTuple{length(σ),I}</li><li>length(::Type{AbstractCell})</li><li><a href="#Base.sign-Tuple{Ripserer.AbstractCell}"><code>sign(::AbstractCell)</code></a></li><li><a href="#Base.:--Tuple{Ripserer.AbstractCell}"><code>Base.:-(::AbstractCell)</code></a></li><li><a href="#Ripserer.coboundary"><code>coboundary(::Any, ::AbstractCell)</code></a></li><li><a href="#Ripserer.boundary"><code>boundary(::Any, ::AbstractCell)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.AbstractSimplex" href="#Ripserer.AbstractSimplex"><code>Ripserer.AbstractSimplex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSimplex{D, T, I&lt;:Integer} &lt;: AbstractCell{I}</code></pre><p>An abstract type for representing simplices. A simplex is an <code>AbstractCell</code> with an integer index. A <code>D</code>-simplex has <code>D + 1</code> vertices.</p><p>If a type implements the interface below, default implementations of <a href="#Ripserer.boundary"><code>boundary</code></a>, <a href="#Ripserer.coboundary"><code>coboundary</code></a>, and <a href="#Graphs.vertices-Tuple{Ripserer.AbstractCell}"><code>vertices</code></a> are provided.</p><p><strong>Interface</strong></p><ul><li><code>AbstractSimplex{0}(::I, ::T)</code></li><li><code>AbstractSimplex{1}(::I, ::T)</code></li><li><a href="#PersistenceDiagrams.birth-Tuple{PersistenceInterval}"><code>birth(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.index-Tuple{Ripserer.AbstractCell}"><code>index(::AbstractSimplex)</code></a></li><li><a href="#Base.sign-Tuple{Ripserer.AbstractCell}"><code>sign(::AbstractSimplex)</code></a></li><li><a href="#Base.:--Tuple{Ripserer.AbstractCell}"><code>Base.:-(::AbstractSimplex)</code></a></li><li><a href="#Ripserer.unsafe_simplex"><code>unsafe_simplex</code></a></li><li><a href="#Ripserer.unsafe_cofacet"><code>unsafe_cofacet</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractsimplex.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{Ripserer.AbstractCell}" href="#Base.sign-Tuple{Ripserer.AbstractCell}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(σ::AbstractCell)</code></pre><p>Get the orientation of <code>σ</code>. Should return -1 or 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sign(Simplex{2}((3, 2, 1), 3.2))
1

julia&gt; sign(-Simplex{2}((3, 2, 1), 3.2))
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L106-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{Ripserer.AbstractCell}" href="#Base.:--Tuple{Ripserer.AbstractCell}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(σ::AbstractCell)</code></pre><p>Reverse the cell orientation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; -Simplex{2}((3, 2, 1), 3.2)
2-dimensional Simplex(index=1, birth=3.2):
  -(3, 2, 1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.coboundary" href="#Ripserer.coboundary"><code>Ripserer.coboundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coboundary(filtration, simplex[, Val{all_cofacets}])</code></pre><p>Iterate over the coboundary of <code>simplex</code> by decreasing <code>index</code>. Use the <code>filtration</code> to determine the diameters and validity of cofacets.</p><p>If <code>all_cofacets</code> is <code>false</code>, only return cofaces with vertices added to the beginning of vertex list. The method with <code>all_cofacets</code> only has to be implemented if the filtration does not overload <a href="#Ripserer.columns_to_reduce"><code>columns_to_reduce</code></a>.</p><p>Comes with a default implementation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If cofacets are not returned in decreasing <code>index</code> order, the algorithm will not work correctly. If there is no avoiding it, define <code>emergent_pairs(...) = false</code> for your filtration.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">filtration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])

for c in Ripserer.coboundary(filtration, Simplex{1}(2, 1))
    println(c)
end

# output

+Simplex{2}((4, 3, 1), 1)
-Simplex{2}((3, 2, 1), 1)</code></pre><pre><code class="language-julia hljs">for c in Ripserer.coboundary(filtration, Simplex{1}(2, 1), Val(false))
    println(c)
end

# output

+Simplex{2}((4, 3, 1), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L161-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ripserer.boundary" href="#Ripserer.boundary"><code>Ripserer.boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary(filtration, simplex[, Val{all_cofacets}])</code></pre><p>Iterate over the boundary of <code>simplex</code> by increasing <code>index</code>. Use the <code>filtration</code> to determine the diameters and validity of cofacets.</p><p>Comes with a default implementation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If facets are not returned in increasing <code>index</code> order, the (homology) algorithm will not work correctly. If there is no avoiding it, define <code>emergent_pairs(...) = false</code> for your filtration.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">filtration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])

for f in Ripserer.boundary(filtration, Simplex{2}(2, 1))
    println(f)
end

# output

+Simplex{1}((2, 1), 1)
-Simplex{1}((4, 1), 1)
+Simplex{1}((4, 2), 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mtsch/Ripserer.jl/blob/f9daa6b7bf8aa5b6283b09c85fd609cb5627d560/src/base/abstractcell.jl#L205-L233">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/basics/">« Usage Guide</a><a class="docs-footer-nextpage" href="../generated/stability/">Stability »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 27 July 2022 19:13">Wednesday 27 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

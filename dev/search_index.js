var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Ripserer-1","page":"API","title":"Ripserer","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"ripserer","category":"page"},{"location":"api/#Ripserer.ripserer","page":"API","title":"Ripserer.ripserer","text":"ripserer(dists::AbstractMatrix{T}; kwargs...)\nripserer(points; metric=Euclidean(), kwargs...)\n\nCompute the persistent homology of metric space represented by dists or points and metric.\n\nKeyoword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nthreshold: compute persistent homology up to diameter smaller than threshold. For Rips filtrations, it defaults to radius of input space.\nsparse: if true, use SparseRipsFiltration. Defaults to false || issparse(dists).\nratio: only keep intervals with death(interval) > birth(interval) * ratio. Defaults to 1.\ncocycles: if true, return representative cocycles along with persistence intervals. Defaults to false.\n\n\n\n\n\nripserer(filtration::AbstractFiltration; dim_max=1)\n\nCompute persistent homology from filtration object.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"RipsFiltration","category":"page"},{"location":"api/#Ripserer.RipsFiltration","page":"API","title":"Ripserer.RipsFiltration","text":"RipsFiltration{T, S<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, S}\n\nConstructor\n\nRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=default_rips_threshold(dist),\n    edge_type=Simplex{1, modulus, T, Int, UInt}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"SparseRipsFiltration","category":"page"},{"location":"api/#Ripserer.SparseRipsFiltration","page":"API","title":"Ripserer.SparseRipsFiltration","text":"SparseRipsFiltration{T, S<:AbstractSimplex{<:Any, T}} <: AbstractFlagFiltration{T, S}\n\nThis type holds the information about the input values. The distance matrix will be converted to a sparse matrix with all values greater than threshold deleted. Off-diagonal zeros in the matrix are treated as ∞.\n\nConstructor\n\nSparseRipsFiltration(\n    distance_matrix;\n    modulus=2,\n    threshold=default_rips_threshold(dist),\n    eltype=Simplex{modulus, T}\n)\n\n\n\n\n\n","category":"type"},{"location":"api/#Persistence-Intervals-and-Diagrams-1","page":"API","title":"Persistence Intervals and Diagrams","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"PersistenceInterval","category":"page"},{"location":"api/#Ripserer.PersistenceInterval","page":"API","title":"Ripserer.PersistenceInterval","text":"PersistenceInterval{T, C}\n\nThe type that represents a persistence interval. It behaves exactly like a Tuple{T, Union{T, Infinity}}, but may have a cocycle attached to it.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"PersistenceDiagram","category":"page"},{"location":"api/#Ripserer.PersistenceDiagram","page":"API","title":"Ripserer.PersistenceDiagram","text":"PersistenceDiagram{P<:PersistenceInterval} <: AbstractVector{P}\n\nType for representing persistence diagrams. Behaves exactly like an immutable array of PersistenceIntervals, but is aware of its dimension and supports pretty printing and plotting.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"RecipesBase.plot(::Union{PersistenceDiagram, AbstractVector{<:PersistenceDiagram}})","category":"page"},{"location":"api/#","page":"API","title":"API","text":"barcode(::Union{PersistenceDiagram, AbstractVector{<:PersistenceDiagram}})","category":"page"},{"location":"api/#Ripserer.barcode-Tuple{Union{AbstractArray{#s1,1} where #s1<:PersistenceDiagram, PersistenceDiagram}}","page":"API","title":"Ripserer.barcode","text":"barcode(diagram; infinity=nothing)\n\nPlot the barcode plot or AbstractVector of diagrams. The infinity keyword argument determines where the infinity line is placed. If set to nothing the function tries to guess a good infinity poistion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simplex-Types-1","page":"API","title":"Simplex Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractSimplex","category":"page"},{"location":"api/#Ripserer.AbstractSimplex","page":"API","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, C, T}\n\nAn abstract type for representing simplices. A simplex is represented by its dimension, diameter, combinatorial index and coefficient value. It does not need to hold information about its the vertices it includes, since they can be recomputed from the index and dimension.\n\nD is the dimension, T is the type of distance and C is the coefficient type. D is accessible by dim(::AbstractSimplex).\n\nInterface\n\nindex(::AbstractSimplex)\ncoef(::AbstractSimplex)\nset_coef(::AbstractSimplex, ::Any)\ndiam(::AbstractSimplex)\ncoface_type(::AbstractSimplex)\nvertices(::AbstractSimplex) - optional, comes with a default implementation.\ncoboundary(::AbstractFiltration, ::AbstractSimplex) - optional, comes with a default implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"index(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.index-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.index","text":"index(simplex::AbstractSimplex)\n\nGet the combinatorial index of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coef(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.coef-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.coef","text":"coef(simplex::AbstractSimplex)\n\nGet the coefficient value of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"set_coef(::AbstractSimplex, ::Any)","category":"page"},{"location":"api/#Ripserer.set_coef-Tuple{AbstractSimplex,Any}","page":"API","title":"Ripserer.set_coef","text":"set_coef(simplex::AbstractSimplex, value)\n\nReturn new simplex of the same type with new coefficient value.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.diam","text":"diam(simplex::AbstractSimplex)\n\nGet the diameter of simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"dim(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.dim-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.dim","text":"dim(::AbstractSimplex)\ndim(::Type{AbstractSimplex})\n\nGet the dimension of simplex i.e. the value of D.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"vertices(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.vertices-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.vertices","text":"vertices(index, ::Val{dim})\n\nGet the vertices of simplex represented by index. Returns NTuple{dim+1, Int}.\n\n\n\n\n\nvertices(sx::AbstractSimplex{dim})\n\nGet the vertices of simplex sx. Returns NTuple{dim+1, Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coface_type(::AbstractSimplex)","category":"page"},{"location":"api/#Ripserer.coface_type-Tuple{AbstractSimplex}","page":"API","title":"Ripserer.coface_type","text":"coface_type(::AbstractSimplex)\ncoface_type(::Type{<:AbstractSimplex})\n\nGet the type of coface a simplex hax. For a D-dimensional simplex, this is usually its D+1-dimensional counterpart. Only the coface_type(::Type{<:AbstractSimplex}) method needs to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"coboundary","category":"page"},{"location":"api/#Ripserer.coboundary","page":"API","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex)\n\nFind the coboundary of simplex. Use the filtration to determine the diameters and validity of cofaces. Iterates values of the type coface_type(simplex).\n\n\n\n\n\n","category":"function"},{"location":"api/#Filtration-Types-1","page":"API","title":"Filtration Types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFiltration","page":"API","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{T, S<:AbstractSimplex{C, T}}\n\nA filtration is used to find the edges in filtration and to determine diameters of simplices.\n\nT is the distance type, accessible by dist_type and S is the edge type, accesible by edge_type.\n\nInterface\n\nn_vertices(::AbstractFiltration)\nedges(::AbstractFiltration)\ndiam(::AbstractFiltration, vs)\ndiam(::AbstractFiltration, ::AbstractSimplex, ::Any, ::Any)\nSparseArrays.issparse(::Type{A}) where A<:AbstractFiltration - optional defaults to false.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"AbstractFlagFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFlagFiltration","page":"API","title":"Ripserer.AbstractFlagFiltration","text":"AbstractFlagFiltration{T, S} <: AbstractFiltration{T, S}\n\nAn abstract flag filtration is a filtration of flag complexes. Its subtypes can overload dist(::AbstractFlagFiltration{T}, u, v)::Union{T, Infinity} instead of diam. diam(::AbstractFlagFiltration, ...) defaults to maximum dist among vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"n_vertices","category":"page"},{"location":"api/#Ripserer.n_vertices","page":"API","title":"Ripserer.n_vertices","text":"n_vertices(filtration::AbstractFiltration)\n\nNumber of vertices in filtration.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"edges","category":"page"},{"location":"api/#Ripserer.edges","page":"API","title":"Ripserer.edges","text":"edges(filtration::AbstractFiltration)\n\nGet edges in distance matrix in filtration, sorted by decresing length and increasing combinatorial index. Edges should be of type edge_type(filtration).\n\n\n\n\n\nedges(dist::AbstractMatrix{T}, thresh, S)\n\nReturn sorted edges of type S in distance matrix with length lower than thresh.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::Any)","category":"page"},{"location":"api/#Ripserer.diam-Tuple{AbstractFiltration,Any}","page":"API","title":"Ripserer.diam","text":"diam(flt::AbstractFiltration, vertices)\n\nGet the diameter of list of vertices i.e. diameter of simplex with vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API","title":"API","text":"diam(::AbstractFiltration, ::Any, ::Any, ::Any)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"SparseArrays.issparse(::AbstractFiltration)","category":"page"},{"location":"api/#SparseArrays.issparse-Tuple{AbstractFiltration}","page":"API","title":"SparseArrays.issparse","text":"SparseArrays.issparse(::Type{A}) where A<:AbstractFiltration\n\nReturn true if A is a sparse filtration. A filtration should be sparse if most simplices are to be skipped. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Plots; gr()","category":"page"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"This package is still under development and is currently unregistered. To install it, run the following.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Pkg\nPkg.add(\"https://github.com/mtsch/Ripserer.jl\")","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Generate 100 points sampled from a torus.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"n = 10\nr = 1\nR = 4\ntorus = [((R + r*cos(θ))*cos(φ), (R + r*cos(θ))*sin(φ), r*sin(θ))\n         for θ in range(0, 2π, length=n+1)[1:end-1]\n         for φ in range(0, 2π, length=n+1)[1:end-1]]\nlength(torus)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Run Ripserer.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Ripserer\nresult = ripserer(torus)","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Plot the result as a persistence diagram or barcode.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"using Plots; gr()\nplot(result)\nsavefig(\"diagram1.svg\"); nothing # hide\nbarcode(result)\nsavefig(\"barcode1.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"We notice some noise around the diagonal. This can be mitigated by running Ripserer with ripserer(torus, ratio=2) or by simply filtering the diagram.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"result[2] = filter(x -> death(x) > 2birth(x), result[2])\nplot(result)\nsavefig(\"diagram2.svg\"); nothing # hide\nbarcode(result)\nsavefig(\"barcode2.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"#Ripserer.jl-1","page":"Home","title":"Ripserer.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient computation of persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Julia implementation of the ripser algorithm for persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Like ripser, Ripserer uses the following optimizations to achieve fast computation of Vietoris-Rips persistent homology.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compute persistent cohomology\nApply the clearing optimization\nDon't store things that can be easily recomputed\nSkip apparent and emergent persistence pairs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a detailed description of the algorithm, please see the original article.","category":"page"},{"location":"#Performance-1","page":"Home","title":"Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to ripser. Depending on the data set, one or the other may be faster and the differences are usually small.","category":"page"},{"location":"#Extending-1","page":"Home","title":"Extending","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. There are currently no extensions available, but implementing one should (in theory) be as simple as overloading a few functions. The interfaces are specified in the docstrings for AbstractSimplex and AbstractFiltration.","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"quickstart.md\",\n         \"api.md\",\n        ]\nDepth = 1","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cocycles.jl\"","category":"page"},{"location":"generated/cocycles/#Cohomology,-Homology,-and-Representatives","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"In this section, we will show how Ripserer can be used to find critical simplices and representative (co)cycles.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"We start by loading some packages and generating some data.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"using LinearAlgebra\nusing Plots\nusing Ripserer\nusing Random # hide\nRandom.seed!(1337) # hide\ngr() # hide\nnothing # hide\n\nfunction annulus(n, r1=1, r2=2, offset=(0, 0))\n    result = Tuple{Float64,Float64}[]\n    while length(result) < n\n        point = 2 * r2 * rand(2) .- r2\n        if r1 < norm(point) < r2\n            push!(result, (point[1] + offset[1], point[2] + offset[2]))\n        end\n    end\n    return result\nend\n\ndata = annulus(300)\n\nscatter(data; label=\"data\", markersize=2, aspect_ratio=1)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's start by taking a look at the persistence diagram.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram = ripserer(data)\nplot(diagram)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The diagram tells us that there is a persistent hole in the data, but tells us nothing about the location of the hole. Ripserer provides several methods to locate it. We'll start with the simplest.","category":"page"},{"location":"generated/cocycles/#Critical-simplices","page":"Cohomology, Homology, and Representatives","title":"Critical simplices","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The first option is to find the death simplex of the interval.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"We start by extracting the interval in question. Keep in mind that the diagrams are sorted by persistence, so the last element will always be the most persistent.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"most_persistent = diagram[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Notice that the interval has two simplices attached to it, the birth simplex and the death simplex. We can extract them with birth_simplex and death_simplex respectively.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"death_sx = death_simplex(most_persistent)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"A simplex acts just like an array of indices, so it can be used to index into the data.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"data[death_sx]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Ripserer also provides a Plots recipe for plotting simplices. It is invoked by passing the simplex and the data to plot. Not that only the edges of the simplices are plotted.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(death_sx, data; label=\"death simplex\")\nplot!(birth_simplex(diagram[2][end]), data; label=\"birth simplex\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The birth simplex is the simplex that first connects the hole. The death simplex is the simplex that fills the hole in.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"While the death simplex gives us a vague idea of where the hole is located, there are other methods available.","category":"page"},{"location":"generated/cocycles/#Representative-Cocycles","page":"Cohomology, Homology, and Representatives","title":"Representative Cocycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"By default, Ripserer computes persistent cohomology. The resulting diagrams of persistent homology and cohomology are the same, but computing cohomology is much more efficient. When computing persistent cohomology, we can tell Ripserer to also compute representative cocycles. This is controlled with the reps keyword argument.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's take a look at the most persistent cocycle of our data set.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram_cocycles = ripserer(data; reps=true)\nmost_persistent_co = diagram_cocycles[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Notice that now, the interval also has a representative attached. The representative is an array of pairs Simplex => value, where the value is the coefficient of the simplex. In reality, the type is different, but it acts exactly the same as a Pair.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"cocycle = representative(most_persistent_co)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The representative can be plotted in the same way as a simplex.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(cocycle, data; label=\"cocycle\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The cocycle is a collection of 1-simplices that, if removed, would break the cycle in our data set. This does not correspond to most people's intuitive understanding of a hole, but it can be useful in some situations. To find something more intuitive, we have to look to homology and its representative cycles.","category":"page"},{"location":"generated/cocycles/#Representative-Cycles","page":"Cohomology, Homology, and Representatives","title":"Representative Cycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Ripserer supports two algorithms for computing representative cocycles. One is computing persistent homology directly, and the other is involuted homology computation. Involuted homology computes cohomology first and then uses its result to recompute cycles. While this increases the running time somewhat, it is still usually much more efficient than computing persistent homology directly. The difference is especially large for filtrations where the number of simplices increases quickly with dimension, such as Vietoris-Rips filtrations. See this paper for more information.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Involuted homology is computed by passing the argument alg=:involuted to ripserer. If we wanted direct homology computation, we would use alg=:homology. The results for both cases are exactly the same.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's try it out. Note that invoking homology also turns on reps for dimensions one and higher.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"diagram_cycles = ripserer(data; alg=:involuted)\nmost_persistent_ho = diagram_cycles[2][end]","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"If an interval with a representative is passed to plot, the representative is plotted.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(most_persistent_ho, data; label=\"cycle\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"The cycle is still not the prettiest, but it at least corresponds to a topological circle wound around the hole in the middle of the data set. Sometimes, the cycle will also have multiple connected components. All except one will be contractible at the time the cycle exists. To make the result look even better, we can try reconstructing the shortest representative cycle.","category":"page"},{"location":"generated/cocycles/#Reconstructed-Shortest-Cycles","page":"Cohomology, Homology, and Representatives","title":"Reconstructed Shortest Cycles","text":"","category":"section"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This method uses information from the cocycle to reconstruct the shortest cycle. Essentially what the method does is that it picks an edge in the cocycle and connects it through the edges in the filtration at the specified time. A limitation of this method is that it only works for one-dimensional representatives.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Reconstruction is done on a per interval basis, as it would take a long time to reconstruct all cycles in large diagrams.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"Let's start with a basic reconstruction.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"filtration = diagram_cocycles[2].filtration\nreconstructed_at_birth = reconstruct_cycle(filtration, most_persistent_co)\n\nscatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(reconstructed_at_birth, data; label=\"reconstruction\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This looks much nicer than the homology example, but could still use some improvement. To improve it, we can set a time at which to reconstruct the cycle.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As time goes on and more simplices are added to the filtration, the shapes of the shortest cycles change as well. The previous example was drawn at interval birth time, which is the default. Let's see what happens if we set the time to the interval midpoint.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"midpoint = (death(most_persistent_co) - birth(most_persistent_co)) / 2\nreconstructed_at_midpoint = reconstruct_cycle(filtration, most_persistent_co, midpoint)\n\nscatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(reconstructed_at_midpoint, data; label=\"reconstruction\")","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As an extreme case, let's look at what the cycle looks like right before its death.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"scatter(data; label=\"data\", markersize=2, aspect_ratio=1)\nplot!(\n    reconstruct_cycle(filtration, most_persistent_co, death(most_persistent_co) - 0.01),\n    data;\n    label=\"reconstruction\",\n)","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"As the time nears the death time, the cycle gets closer to looking like the death simplex.","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"","category":"page"},{"location":"generated/cocycles/","page":"Cohomology, Homology, and Representatives","title":"Cohomology, Homology, and Representatives","text":"This page was generated using Literate.jl.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The following tables show benchmarks that compare Ripserer's performance with Ripser, Cubical Ripser, and Eirene.jl. The benchmarking code and more info about the datasets are available here.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmarks were performed on a laptop with an Intel(R) Core(TM) i5-4200U CPU @ 1.60GHz with 8GB of RAM.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We used BenchmarkTools.jl to perform the timing benchmarks and Valgrind's Massif tool to measure peak heap sizes (i.e. total memory footprint).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks were performed with Ripserer v0.15, master versions of Ripser (commit hash 286d369) and Cubical Ripser (commit hashes 6edb9c5 for 2D and a063dac for 3D), and Eirene v1.3.5.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The timings show the minimum time taken among five runs of the benchmark.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The heap sizes for Ripserer include the Julia runtime.","category":"page"},{"location":"benchmarks/#Comparison-with-Ripser","page":"Benchmarks","title":"Comparison with Ripser","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In this experiment, we performed benchmarks with the datasets presented in the Ripser article. We only used the datasets that we were able to run with less than 8GB memory. All datasets were parsed as Float32 as that is what Ripser supports. The time it takes to parse a file is included for both Ripser and Ripserer.","category":"page"},{"location":"benchmarks/#Dense-results","page":"Benchmarks","title":"Dense results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Ripser ratio Ripserer heap Ripser heap\no3_1024 1024 3 1.8 4.576 s 3.057 s 1.497 374.1 MiB 151.0 MiB\no3_4096 4096 3 1.4 151.527 s 76.177 s 1.989 4.7 GiB 4.1 GiB\ndragon2000 2000 1  3.133 s 2.833 s 1.106 316.7 MiB 296.8 MiB\nfract-r 512 2  22.807 s 19.482 s 1.171 2.2 GiB 2.0 GiB\nrandom16 50 2  8 ms 10 ms 0.803 111.1 MiB 1.1 MiB\nsphere_3_192 192 2  1.549 s 1.491 s 1.039 287.0 MiB 209.5 MiB","category":"page"},{"location":"benchmarks/#Sparse-results","page":"Benchmarks","title":"Sparse results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These benchmarks were performed with the sparse=true keyword argument.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Ripser ratio Ripserer heap Ripser heap\no3_1024 1024 3 1.8 3.036 s 3.057 s 0.993 418.2 MiB 151.0 MiB\no3_4096 4096 3 1.4 76.052 s 76.177 s 0.998 4.9 GiB 4.1 GiB\ndragon2000 2000 1  3.588 s 2.833 s 1.267 350.4 MiB 296.8 MiB\nfract-r 512 2  25.399 s 19.482 s 1.304 2.2 GiB 2.0 GiB\nrandom16 50 2  9 ms 10 ms 0.932 111.1 MiB 1.1 MiB\nsphere_3_192 192 2  1.734 s 1.491 s 1.163 288.5 MiB 209.5 MiB","category":"page"},{"location":"benchmarks/#Alpha-Rips","page":"Benchmarks","title":"Alpha-Rips","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These benchmarks were performed on sparse matrices that correspond to the 1-skeleta of Delaunay triangulations. The purpose of these is to show performance with very sparse inputs.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim Ripserer Ripser ratio Ripserer heap Ripser heap\nalpha_3_sphere_3000 3000 3 636 ms 789 ms 0.807 138.4 MiB 33.2 MiB\nalpha_torus_10_000 10000 2 872 ms 1.179 s 0.741 130.0 MiB 27.7 MiB\nalpha_5_sphere_1000 1000 5 49.431 s 46.707 s 1.058 387.2 MiB 202.0 MiB\nalpha_dragon_2000 2000 2 56 ms 76 ms 0.744 2.4 GiB 1.5 GiB\nalpha_4_sphere_2000 2000 4 5.844 s 6.203 s 0.942 110.9 MiB 33.2 MiB","category":"page"},{"location":"benchmarks/#Comparison-with-Cubical-Ripser","page":"Benchmarks","title":"Comparison with Cubical Ripser","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In these benchmarks, we used some of the datasets presented in the Cubical Ripser article. We limited the 2D image size to 1999×999 as the current master (commit hash 6edb9c5) version of 2D Cubical Ripser throws an assertion error for anything larger. We were also unable to perform 3D 256×256×256 image benchmarks due to Ripserer running out of memory. The eltype of all datasets is Float64, because that is what Cubical Ripser supports. When running Ripserer in the real world, it's a good idea to use the image's native data types. This will slightly reduce the memory footprint and increase performance.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim Ripserer Cubical Ripser ratio Ripserer heap Cubical Ripser heap\nlena512 262144 1 787 ms 299 ms 2.631 145.0 MiB 49.3 MiB\nlena1999x999 1997001 1 2.87 s 2.009 s 1.429 514.4 MiB 186.7 MiB\nbonsai64 262144 2 2.875 s 2.996 s 0.96 280.6 MiB 1.3 GiB\nbonsai128 2097152 2 31.151 s 14.733 s 2.114 1.5 GiB 1.9 GiB\nhead128 2097152 2 24.102 s 12.434 s 1.938 1.5 GiB 1.9 GiB","category":"page"},{"location":"benchmarks/#Comparison-with-Eirene","page":"Benchmarks","title":"Comparison with Eirene","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In these benchmarks, we compare Ripserer to Eirene.jl. Ripserer benchmarks were run with alg=:involuted, so this measures the time it takes to compute representative cycles.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"dataset size dim threshold Ripserer Eirene ratio\ngcycle 100 3  6.231 s 24.158 s 0.258\nhiv 1088 1  1.824 s 7.774 s 0.235\ndragon1000 1000 1  575 ms 8.441 s 0.068\ncelegans 297 2  4.217 s 4.588 s 0.919\no3_1024 1024 3 1.8 5.735 s 8.314 s 0.69\nrandom16 50 7  8.577 s 7.688 s 1.116","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Ripserer","page":"API","title":"Ripserer","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ripserer","category":"page"},{"location":"api/#Ripserer.ripserer","page":"API","title":"Ripserer.ripserer","text":"ripserer(Type{<:AbstractFiltration}, args...; kwargs...)\nripserer(filtration::AbstractFiltration; kwargs...)\n\nCompute the persistent homology of a filtration. The filtration can be given as an AbstractFiltration type, followed by its arguments, or as an initialized object (see examples below). If only data is given, Rips is used by default.\n\nReturns a Vector of PersistenceDiagrams with (dim_max + 1) elements. The diagrams are sorted by dimension; the first element of the result is the 0-dimensional diagram, and the last is the (dim_max)-dimensional diagram.\n\nKeyword Arguments\n\ndim_max: compute persistent homology up to this dimension. Defaults to 1.\nmodulus: compute persistent homology with coefficients in the prime field of integers mod modulus. Defaults to 2.\nfield: use this type of field of coefficients. Defaults to Ripserer.Mod{modulus}.\nthreshold: compute persistent homology up to diameter smaller than threshold. Note that this parameter is passed to the filtration constructor. When using low thresholds with Rips filtrations, consider setting sparse=true for optimal performance.\ncutoff: only keep intervals with persistence(interval) > cutoff. Defaults to 0. When cutoff < 0, the result will also contain zero-length intervals.\nreps: if true, attach representative (co)cycles to persistence intervals. Can also be set to collection of integers to only find representatives in specified dimensions, e.g. reps=1:2 will only find representatives in dimensions 1 and 2. This is useful for large filtrations (such as cubical) where calculating zero-dimensional representatives can be very slow. Defaults to false for cohomology and 1:dim_max for homology. Representatives are wrapped in a Chain.\nverbose: If true, show a verbose bar. Defaults to false.\nalg: select the algorithm used in computation. The options are:\n:cohomology: Default and fastest algorithm. When reps is set, intervals are equipped with representative cocycles.\n:homology: Significantly slower than :cohomology, but finds representative cycles. Does not find infinite intervals beyond dimension 0.\n:involuted: Use cohomology result to compute representative cycles. Can be extremely efficient compared to :homology, especially with Rips filtrations. See this paper for more information.\nimplicit: If true, an implicit reduction algorithm is used. Defaults to true for :cohomology and :involuted, and false for :homology. implicit=false is not recommended for :cohomology because it disables the emergent pairs optimization.\n\nOther kwargs... are passed to the filtration.\n\nExamples\n\njulia> ts = range(0, 2π; length=20)[1:(end - 1)];\n\njulia> X = [((2 + cos(θ)) * cos(φ), (2 + cos(θ)) * sin(φ), sin(θ)) for θ in ts for φ in ts];\n\njulia> ripserer(X)\n2-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 361-element 0-dimensional PersistenceDiagram\n 362-element 1-dimensional PersistenceDiagram\n\njulia> ripserer(EdgeCollapsedRips, X; modulus=7, threshold=2)\n2-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 361-element 0-dimensional PersistenceDiagram\n 362-element 1-dimensional PersistenceDiagram\n\njulia> ripserer(Rips(X; threshold=1); alg=:involuted)\n2-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 361-element 0-dimensional PersistenceDiagram\n 362-element 1-dimensional PersistenceDiagram\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Filtrations","page":"API","title":"Filtrations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Rips","category":"page"},{"location":"api/#Ripserer.Rips","page":"API","title":"Ripserer.Rips","text":"Rips{I, T} <: AbstractRipsFiltration{I, T}\n\nThis type represents a filtration of Vietoris-Rips complexes.\n\nDiagonal items in the input matrix are treated as vertex birth times.\n\nZero values are not allowed due to how sparse matrices work in Julia. If you need zero birth times, try offseting all values by a constant.\n\nThreshold defaults to the radius of the input space. When using low thresholds, consider using the sparse=true keyword argument. It will give the same result, but may be much faster.\n\nConstructors\n\nRips(distance_matrix; threshold=nothing)\nRips(points; metric=Euclidean(1e-12), threshold=nothing)\nRips{I}(args...): I sets the size of integer used to represent simplices.\n\nExamples\n\njulia> data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)][1:end-1];\n\njulia> ripserer(Rips(data))\n2-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 100-element 0-dimensional PersistenceDiagram\n 1-element 1-dimensional PersistenceDiagram\n\njulia> ripserer(Rips(data, threshold=1.7))[2]\n1-element 1-dimensional PersistenceDiagram:\n [0.0628, ∞)\n\njulia> using Distances\n\njulia> ripserer(Rips(data, metric=Cityblock()))[2]\n1-element 1-dimensional PersistenceDiagram:\n [0.0888, 2.0)\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Cubical","category":"page"},{"location":"api/#Ripserer.Cubical","page":"API","title":"Ripserer.Cubical","text":"Cubical{T, K} <: AbstractFiltration{CartesianIndex{K}, T}\n\nCubical is used to compute sublevel persistent homology on N-dimensional images, which are of type AbstractArray{T, N}.\n\nThis type uses the CubeMap structure to find birth times of cubes (see reference).\n\nConstructor\n\nCubical(image::AbstractArray{T, N}, threshold=maximum(image))\n\nReference\n\nWagner, H., Chen, C., & Vuçini, E. (2012). Efficient computation of persistent homology for cubical data. In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.\n\nExample\n\njulia> image = [1 0 0; 0 2 0; 0 0 0];\n\njulia> ripserer(Cubical(image))[1]\n1-element 0-dimensional PersistenceDiagram:\n [0.0, ∞)\n\njulia> ripserer(Cubical(image))[2]\n1-element 1-dimensional PersistenceDiagram:\n [1.0, 2.0)\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Custom","category":"page"},{"location":"api/#Ripserer.Custom","page":"API","title":"Ripserer.Custom","text":"Custom{I, T} <: AbstractCustomFiltration{I, T}\n\nBuild a custom filtration by specifying simplices and their birth times.\n\nThe list of simplices is corrected to form a valid filtration; birth times are corrected so a simplex is never born before its faces and missing simplices are added.\n\nSee the examples below for construction. Note how the unlisted 0-simplices were added with birth times equal to the lowest between their cofaces. The order in which simplices are given does not matter.\n\nTo create your own types of custom filtrations, subtype AbstractCustomFiltration.\n\nExamples\n\njulia> flt = Custom([(1,) => 0, (4,) => 0, (1, 2) => 1, (1, 3) => 2, (1, 4) => 3, (2, 3) => 4, (2, 4) => 5, (3, 4) => 6, (1, 2, 3) => 7, (1, 2, 4) => 8, (1, 3, 4) => 9]; threshold=8)\nCustom{Int64, Int64}(nv=4)\n\njulia> flt[0] # Can be indexed with dimension to list simplices\n4-element Vector{Simplex{0, Int64, Int64}}:\n +Simplex{0}((4,), 0)\n +Simplex{0}((2,), 1)\n +Simplex{0}((3,), 2)\n +Simplex{0}((1,), 0)\n\njulia> ripserer(flt)[1]\n2-element 0-dimensional PersistenceDiagram:\n [0.0, 3.0)\n [0.0, ∞)\n\njulia> ripserer(flt)[2]\n3-element 1-dimensional PersistenceDiagram:\n [5.0, 8.0)\n [4.0, 7.0)\n [6.0, ∞)\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Alpha","category":"page"},{"location":"api/#Ripserer.Alpha","page":"API","title":"Ripserer.Alpha","text":"Alpha{I, P<:SVector} <: AbstractFiltration{I, Float64}\n\nAlpha filtrations are filtrations of the Delaunay complex.\n\nThey have much fewer simplices than Rips, so they are efficient even with large datasets, as long as their dimensionality is low.  What \"low\" means depends on the data, but this is definitely a good choice for 3D or lower. For high dimensional data, filtration construction may take a long time.\n\nnote: Note\nUnlike most implementations, this one uses circumdiameters instead of circumradii. This makes the scale of the results comparable to Rips. If you need radius based values, divide your data or the resulting interval endpoints by 2.\n\nwarning: Warning\nThis filtration uses MiniQhull.jl. Please see the installation instructions if constructions cause errors. MiniQhull currently has problems running on Windows. See this issue for more info.\n\nConstructors\n\nAlpha(points; threshold, verbose): points should be a vector of Tuples, SVectors or similar.\nAlpha{I}(args...): I sets the size of integer used to represent simplices. Try using I=Int128 if construction complains about overflow.\n\nReference\n\nEdelsbrunner, H. (1993, July). The union of balls and its dual shape. In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231).\n\nExample\n\njulia> data = [(sin(t), cos(t), (t - π)^2) for t in range(0, 2π, length=101)[1:end-1]];\n\njulia> alpha = Alpha(data)\nAlpha{Int64, Float64}(nv=100)\n\njulia> rips = Rips(data)\nRips{Int64, Float64}(nv=100, sparse=false)\n\njulia> length(Ripserer.edges(alpha))\n197\n\njulia> length(Ripserer.edges(rips))\n3613\n\njulia> sort(ripserer(alpha)[2], by=persistence)[end]\n[0.375, 2.01) with:\n birth_simplex: Ripserer.Simplex{1, Float64, Int64}\n death_simplex: Ripserer.Simplex{2, Float64, Int64}\n\njulia> sort(ripserer(rips)[2], by=persistence)[end]\n[0.375, 2.01) with:\n birth_simplex: Ripserer.Simplex{1, Float64, Int64}\n death_simplex: Ripserer.Simplex{2, Float64, Int64}\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"EdgeCollapsedRips","category":"page"},{"location":"api/#Ripserer.EdgeCollapsedRips","page":"API","title":"Ripserer.EdgeCollapsedRips","text":"EdgeCollapsedRips{I, T} <: AbstractRipsFiltration{I, T}\n\nPerform a sequence of edge collapses on a filtration. This may significantly reduce computation time and does not change the result. The speedup is especially apparent with datasets that have a boundary, and with high-dimensional persistent homology computation.\n\nThe drawback is that doing the collapses themselves can be time-consuming. The construction does not require a lot of memory (mathcalO(n^2) for n vertices). This might still be a good choice for large inputs if you are willing to wait but don't have enough memory to compute persistent homology with Rips.\n\nSee the reference below for a description of the algorithm.\n\nConstructors\n\nEdgeCollapsedRips(::AbstractRipsFiltration; verbose=false, threshold=nothing ): Collapse a given filtration. Setting verbose shows a progress bar.\nEdgeCollapsedRips(::EdgeCollapsedRips; verbose=false, threshold=nothing): Allows changing I or threshold without recomputing.\nEdgeCollapsedRips(arg; kwargs...): Use arg and kwargs to construct a Rips filtration and collapse it\nEdgeCollapsedRips{I}(arg; kwargs...): Change the index type used to represent simplices. May be necessary for large inputs and high-dimensional computation.\n\nExamples\n\njulia> using Random; Random.seed!(1337);\n\njulia> data = [tuple(rand(6)...) for _ in 1:100];\n\njulia> rips = Rips(data)\nRips{Int64, Float64}(nv=100, sparse=false)\n\njulia> length(Ripserer.edges(rips))\n3934\n\njulia> collapsed = EdgeCollapsedRips(data) # or EdgeCollapsedRips(rips)\nEdgeCollapsedRips{Int64, Float64}(nv=100)\n\njulia> length(Ripserer.edges(collapsed))\n1324\n\njulia> ripserer(rips) == ripserer(collapsed)\ntrue\n\njulia> ripserer(collapsed; dim_max=4)\n5-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 100-element 0-dimensional PersistenceDiagram\n 58-element 1-dimensional PersistenceDiagram\n 35-element 2-dimensional PersistenceDiagram\n 10-element 3-dimensional PersistenceDiagram\n 4-element 4-dimensional PersistenceDiagram\n\n\nReference\n\nBoissonnat, J. D., & Pritam, S. (2019). Edge Collapse and Persistence of Flag Complexes.\n\n\n\n\n\n","category":"type"},{"location":"api/#Persistence-Diagrams","page":"API","title":"Persistence Diagrams","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Persistence diagrams live in a separate package, PersistenceDiagrams.jl. The package is documented in detail here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"If you are looking for Wasserstein or bottleneck distances, persistence images, betti curves, landscapes, and similar, you will need to run using PersistenceDiagrams.","category":"page"},{"location":"api/","page":"API","title":"API","text":"For convenience, the following basic functionality is reexported by Ripserer:","category":"page"},{"location":"api/","page":"API","title":"API","text":"PersistenceDiagrams.PersistenceDiagram","category":"page"},{"location":"api/#PersistenceDiagrams.PersistenceDiagram","page":"API","title":"PersistenceDiagrams.PersistenceDiagram","text":"PersistenceDiagram <: AbstractVector{PersistenceInterval}\n\nType for representing persistence diagrams. Behaves exactly like a vector of PersistenceIntervals, but can have additional metadata attached to it. It supports pretty printing and plotting.\n\nCan be used as a table with any function that uses the Tables.jl interface. Note that using it as a table will only keep interval endpoints and the dim and threshold attributes.\n\nExample\n\njulia> diagram = PersistenceDiagram([(1, 3), (3, 4), (1, Inf)]; dim=1, custom_metadata=:a)\n3-element 1-dimensional PersistenceDiagram:\n [1.0, 3.0)\n [3.0, 4.0)\n [1.0, ∞)\n\njulia> diagram[1]\n[1.0, 3.0)\n\njulia> sort(diagram; by=persistence, rev=true)\n3-element 1-dimensional PersistenceDiagram:\n [1.0, ∞)\n [1.0, 3.0)\n [3.0, 4.0)\n\njulia> propertynames(diagram)\n(:intervals, :dim, :custom_metadata)\n\njulia> dim(diagram)\n1\n\njulia> diagram.custom_metadata\n:a\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"PersistenceDiagrams.PersistenceInterval","category":"page"},{"location":"api/#PersistenceDiagrams.PersistenceInterval","page":"API","title":"PersistenceDiagrams.PersistenceInterval","text":"PersistenceInterval\n\nType for representing persistence intervals. It behaves exactly like a Tuple{Float64, Float64}, but can have meta data attached to it. The metadata is accessible with getproperty or the dot syntax.\n\nExample\n\njulia> interval = PersistenceInterval(1, Inf; meta1=:a, meta2=:b)\n[1.0, ∞) with:\n meta1: Symbol\n meta2: Symbol\n\njulia> birth(interval), death(interval), persistence(interval)\n(1.0, Inf, Inf)\n\njulia> isfinite(interval)\nfalse\n\njulia> propertynames(interval)\n(:birth, :death, :meta1, :meta2)\n\njulia> interval.meta1\n:a\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"birth(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.birth-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.birth","text":"birth(interval)\n\nGet the birth time of interval.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"death(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.death-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.death","text":"death(interval)\n\nGet the death time of interval.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"persistence(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.persistence-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.persistence","text":"persistence(interval)\n\nGet the persistence of interval, which is equal to death - birth.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"midlife","category":"page"},{"location":"api/#PersistenceDiagrams.midlife","page":"API","title":"PersistenceDiagrams.midlife","text":"midlife(interval)\n\nGet the midlife of the interval, which is equal to (birth + death) / 2.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"representative(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.representative-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.representative","text":"representative(interval::PersistenceInterval)\n\nGet the representative (co)cycle attached to interval, if it has one.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"birth_simplex(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.birth_simplex-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.birth_simplex","text":"birth_simplex(interval::PersistenceInterval)\n\nGet the critical birth simplex of interval, if it has one.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"death_simplex(::PersistenceDiagrams.PersistenceInterval)","category":"page"},{"location":"api/#PersistenceDiagrams.death_simplex-Tuple{PersistenceInterval}","page":"API","title":"PersistenceDiagrams.death_simplex","text":"death_simplex(interval::PersistenceInterval)\n\nGet the critical death simplex of interval, if it has one.\n\nnote: Note\nAn infinite interval's death simplex is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"barcode","category":"page"},{"location":"api/#PersistenceDiagrams.barcode","page":"API","title":"PersistenceDiagrams.barcode","text":"barcode(diagram)\n\nPlot the barcode plot of persistence diagram or multiple diagrams in a collection. The infinity keyword argument determines where the infinity line is placed. If unset, the function tries to use threshold(diagram), or guess a good position to place the line at.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simplices-and-Representatives","page":"API","title":"Simplices and Representatives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Ripserer.Simplex","category":"page"},{"location":"api/#Ripserer.Simplex","page":"API","title":"Ripserer.Simplex","text":"Simplex{D, T, I<:Integer} <: AbstractSimplex{D, T, I}\n\nThe vanilla simplex type represented by dimension D, an index of type I, and a birth time of type T.\n\nConstructors\n\nSimplex{D[, T, I]}(index, birth)\nSimplex{D}(vertices, birth): vertices must be sorted descending. This constructor mainly exists for debugging purposes. Using simplex is usually the better option.\n\nExamples\n\njulia> sx = Simplex{2}(2, 1)\n2-dimensional Simplex(index=2, birth=1):\n  +(4, 2, 1)\n\njulia> index(sx)\n2\n\njulia> vertices(sx)\n(4, 2, 1)\n\njulia> birth(sx)\n1\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.Cube","category":"page"},{"location":"api/#Ripserer.Cube","page":"API","title":"Ripserer.Cube","text":"Cube{D, T, K} <: AbstractCell{D, T, CartesianIndex{K}}\n\nA Cube is similar to a Simplex, but it has 2^D vertices instead of D+1. The vertices are encoded as the position in the CubeMap (see reference in Cubical). A Cube's vertices are of type CartesianIndex{K}.\n\nExample\n\njulia> Cube{1}(CartesianIndex(1, 2), 1.0)\nCube{1, Float64, 2}((1, 2), 1.0)\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.dim(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#PersistenceDiagrams.dim-Tuple{Ripserer.AbstractCell}","page":"API","title":"PersistenceDiagrams.dim","text":"dim(::AbstractCell)\ndim(::Type{<:AbstractCell})\n\nGet the dimension of a cell i.e. the value of D. Can also be called on the type.\n\nExamples\n\njulia> dim(Simplex{2}((3, 2, 1), 3.2))\n2\n\njulia> dim(Cube{3, Int, 4})\n3\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.birth(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#PersistenceDiagrams.birth-Tuple{Ripserer.AbstractCell}","page":"API","title":"PersistenceDiagrams.birth","text":"birth(σ::AbstractCell)\n\nGet the birth time of σ, i.e. the time it first appears in the filtration.\n\nExample\n\njulia> birth(Simplex{2}((3, 2, 1), 3.2))\n3.2\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.index(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#Ripserer.index-Tuple{Ripserer.AbstractCell}","page":"API","title":"Ripserer.index","text":"index(σ::AbstractCell)\n\nGet the combinatorial index of the σ. The index can be any type, but should uniquely identify a cell. It is also used to break ties when comparing simplices with the same birth time.\n\njulia> index(Simplex{2}((3, 2, 1), 3.2))\n1\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.vertices(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#Graphs.vertices-Tuple{Ripserer.AbstractCell}","page":"API","title":"Graphs.vertices","text":"vertices(σ::AbstractCell{D,T,I})::NTuple{length(σ),I}\n\nGet the vertices of σ.\n\nExample\n\njulia> vertices(Simplex{2}((3, 2, 1), 3.2))\n(3, 2, 1)\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.Chain","category":"page"},{"location":"api/#Ripserer.Chain","page":"API","title":"Ripserer.Chain","text":"Chain{F,S,E} <: AbstractVector{ChainElement{S,F}}\n\nAn internal representation of a chain. Behaves like an array of pairs S => F, where S is the simplex type, and F is the coefficient type (probably a subtype of Mod).\n\nMost functions that can be called on AbstractCells can also be called on the elements of a Chain.\n\nExamples\n\njulia> data = [(rand(), rand(), rand()) for _ in 1:100];\n\njulia> result = ripserer(data; reps=true, modulus=7);\n\njulia> chain = result[end][end].representative\n28-element Chain{Ripserer.Mod{7},Ripserer.Simplex{1, Float64, Int64}}:\n +Simplex{1}((68, 54), 0.25178097927369875) => 6 mod 7\n +Simplex{1}((54, 46), 0.2575262844682746) => 1 mod 7\n +Simplex{1}((88, 56), 0.25936896586973557) => 1 mod 7\n +Simplex{1}((79, 22), 0.26690101517910964) => 6 mod 7\n +Simplex{1}((53, 13), 0.27161939814693414) => 6 mod 7\n +Simplex{1}((24, 13), 0.28686687771884056) => 6 mod 7\n +Simplex{1}((56, 54), 0.2869400047523196) => 6 mod 7\n +Simplex{1}((50, 42), 0.29274772369750884) => 6 mod 7\n +Simplex{1}((93, 50), 0.3022995886824861) => 1 mod 7\n +Simplex{1}((73, 54), 0.30771273548368216) => 6 mod 7\n ⋮\n +Simplex{1}((70, 34), 0.3412250751087395) => 6 mod 7\n +Simplex{1}((49, 42), 0.3414959312908324) => 6 mod 7\n +Simplex{1}((49, 7), 0.35568373080560794) => 6 mod 7\n +Simplex{1}((88, 46), 0.35629002982624475) => 1 mod 7\n +Simplex{1}((95, 88), 0.3566986102316938) => 6 mod 7\n +Simplex{1}((95, 54), 0.363029725360828) => 6 mod 7\n +Simplex{1}((50, 13), 0.3648936036309352) => 6 mod 7\n +Simplex{1}((24, 3), 0.3653704317993549) => 6 mod 7\n +Simplex{1}((85, 42), 0.369953146904745) => 6 mod 7\n\njulia> simplex.(chain)\n28-element Vector{Simplex{1, Float64, Int64}}:\n +Simplex{1}((68, 54), 0.25178097927369875)\n +Simplex{1}((54, 46), 0.2575262844682746)\n +Simplex{1}((88, 56), 0.25936896586973557)\n +Simplex{1}((79, 22), 0.26690101517910964)\n +Simplex{1}((53, 13), 0.27161939814693414)\n +Simplex{1}((24, 13), 0.28686687771884056)\n +Simplex{1}((56, 54), 0.2869400047523196)\n +Simplex{1}((50, 42), 0.29274772369750884)\n +Simplex{1}((93, 50), 0.3022995886824861)\n +Simplex{1}((73, 54), 0.30771273548368216)\n ⋮\n +Simplex{1}((70, 34), 0.3412250751087395)\n +Simplex{1}((49, 42), 0.3414959312908324)\n +Simplex{1}((49, 7), 0.35568373080560794)\n +Simplex{1}((88, 46), 0.35629002982624475)\n +Simplex{1}((95, 88), 0.3566986102316938)\n +Simplex{1}((95, 54), 0.363029725360828)\n +Simplex{1}((50, 13), 0.3648936036309352)\n +Simplex{1}((24, 3), 0.3653704317993549)\n +Simplex{1}((85, 42), 0.369953146904745)\n\njulia> vertices.(chain)\n28-element Vector{Tuple{Int64, Int64}}:\n (68, 54)\n (54, 46)\n (88, 56)\n (79, 22)\n (53, 13)\n (24, 13)\n (56, 54)\n (50, 42)\n (93, 50)\n (73, 54)\n ⋮\n (70, 34)\n (49, 42)\n (49, 7)\n (88, 46)\n (95, 88)\n (95, 54)\n (50, 13)\n (24, 3)\n (85, 42)\n\njulia> coefficient.(chain)\n28-element Vector{Mod{7}}:\n 6 mod 7\n 1 mod 7\n 1 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 1 mod 7\n 6 mod 7\n       ⋮\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 1 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n 6 mod 7\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Mod","category":"page"},{"location":"api/#Ripserer.Mod","page":"API","title":"Ripserer.Mod","text":"Mod{M} <: Integer\n\nMod{M} is the default field used by Ripserer. It is a representation of a finite field mathbbZ_M, integers modulo small, prime M. Supports field arithmetic and can be converted to integer with Int.\n\nIts values are not comparable on purpose.\n\nExample\n\njulia> Mod{3}(5)\n2 mod 3\n\njulia> Mod{3}(5) + 1\n0 mod 3\n\n\n\n\n\n\n","category":"type"},{"location":"api/#MLJ.jl-Interface","page":"API","title":"MLJ.jl Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Ripserer.RipsPersistentHomology","category":"page"},{"location":"api/#Ripserer.RipsPersistentHomology","page":"API","title":"Ripserer.RipsPersistentHomology","text":"RipsPersistentHomology\n\nCompute Vietoris-Rips persistent homology and convert the results to a table of continuous values.\n\n!!! warning Warning     Computing Vietoris-Rips persistent homology may be CPU and memory intensive even for     modestly-sized data sets. Consider using AlphaPersistentHomology for     low-dimensional data.\n\nHyperparameters\n\nvectorizer = PersistenceImageVectorizer(): AbstractVectorizer used to transform persistence diagrams to continuous vectors. See the PersistenceDiagrams.jl Documentation for more information.\ndim_max = 1: compute persistent homology up to this dimension.\nmodulus = 2: compute persistent homology with coefficients in the prime field of integers mod modulus.\nthreshold = nothing: compute persistent homology up to diameter smaller than threshold.\ncutoff = 0: only keep intervals with persistence(interval) > cutoff.\nsparse = false: use a sparse Rips filtration.\ncollapse = false: use the EdgeCollapsedRips filtration. This is usually a good choice for computations with a high dim_max.\n\nSee also\n\nripserer\nRips\nEdgeCollapsedRips\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AlphaPersistentHomology","category":"page"},{"location":"api/#Ripserer.AlphaPersistentHomology","page":"API","title":"Ripserer.AlphaPersistentHomology","text":"AlphaPersistentHomology\n\nCompute alpha complex persistent homology and convert the results to a table of continuous values.\n\n!!! warning Warning     Using high-dimensional data with this model may be computationaly expensive. Consider     using RipsPersistentHomology.\n\nwarning: Warning\nThis model uses MiniQhull.jl. Please see the installation instructions if fitting causes errors. MiniQhull currently has problems running on Windows. See this issue for more info.\n\nHyperparameters\n\nvectorizer = PersistenceImageVectorizer(): AbstractVectorizer used to transform persistence diagrams to continuous vectors. See the PersistenceDiagrams.jl Documentation for more information.\ndim_max = 1: compute persistent homology up to this dimension.\nmodulus = 2: compute persistent homology with coefficients in the prime field of integers mod modulus.\nthreshold = nothing: compute persistent homology up to diameter smaller than threshold.\ncutoff = 0: only keep intervals with persistence(interval) > cutoff.\n\nSee also\n\nripserer\nAlpha\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.CubicalPersistentHomology","category":"page"},{"location":"api/#Ripserer.CubicalPersistentHomology","page":"API","title":"Ripserer.CubicalPersistentHomology","text":"CubicalPersistentHomology\n\nCompute cubical persistent homology and convert the results to a table of continuous values.\n\nHyperparameters\n\nvectorizer = PersistenceImageVectorizer(): AbstractVectorizer used to transform persistence diagrams to continuous vectors. See the PersistenceDiagrams.jl Documentation for more information.\ndim_max = 1: compute persistent homology up to this dimension.\nthreshold = nothing: compute persistent homology up to diameter smaller than threshold.\ncutoff = 0: only keep intervals with persistence(interval) > cutoff.\nnegate = false: negate the image before computation.\n\nSee also\n\nripserer\nCubical\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimental-Features","page":"API","title":"Experimental Features","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Ripserer.reconstruct_cycle","category":"page"},{"location":"api/#Ripserer.reconstruct_cycle","page":"API","title":"Ripserer.reconstruct_cycle","text":"reconstruct_cycle(filtration, interval[, t]; distances=distance_matrix(filtration))\n\nReconstruct the shortest representative cycle for the first homology group of given interval. The optional argument t sets the time at which the cycle is to be computed. It defaults to interval birth time, which gives a cycle similar to a representative cycle computed from homology. In general, higher times will yield nicer cycles. t can be a simplex or a number.\n\nThe optional distances keyword argument can be used to change the distance matrix used for determining edge lengths.\n\nThis method uses the representative cocycle to compute the cycle. As such, the interval must be computed with the default cohomology algorithm and must include a representative. To get such an interval, run ripserer with the keyword argument reps=true or reps=1.\n\nNote that this method only works in the first dimension, as it is based on finding shortest paths in a graph.\n\nwarning: Warning\nThis feature is still experimental.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.Partition","category":"page"},{"location":"api/#Ripserer.Partition","page":"API","title":"Ripserer.Partition","text":"module Partition\n\nThis submodule contains the following partition functions to be used with circular coordinates.\n\nPartition.linear(r, d) = max(r - d, 0.0)\nPartition.quadratic(r, d) = (max(r - d, 0.0))^2\nPartition.exponential(r, d) = r - d > 0 ? exp(r^2/(d^2 - r^2)) : 0.0\n\n\n\n\n\n","category":"module"},{"location":"api/","page":"API","title":"API","text":"Ripserer.CircularCoordinates","category":"page"},{"location":"api/#Ripserer.CircularCoordinates","page":"API","title":"Ripserer.CircularCoordinates","text":"CircularCoordinates\n\nThis struct implements Perea's sparse circular coordinates (see reference below).\n\nThe idea behind this method is that you pick a subset of your data set (also called landmarks), compute persistent cohomology on that subset, and use the result to construct circular coordinates on the whole data set.\n\nFor this to work correctly, you need the following.\n\nA set of landmarks that cover the points well. The default minmax sampling method is\n\nusually a good choice here.\n\nThe persistence diagram on the landmarks must have an interval that is persistent enough.\n\nThe circular coordinates returned are on the interval [0, 1). If you are looking for angles, make sure to multiply them by 2π.\n\nIf you try to compute circular coordinates for a point that is not near any landmark, the result will be missing.\n\nConstructor\n\nCircularCoordinates([::AbstractFiltration, ]points, landmarks; kwargs...)\n\nArguments\n\npoints: a vector of points. The eltype of this vector can be Tuples, SVectors, or similar.\nlandmarks: can be an integer, a vector of indices, or a vector of points. If set to an integer, it sets the number of landmarks to choose with maxmin sampling. If you are looking for non-sparse circular coordinates, use landmarks=eachindex(points).\nout_dim: number of most persistent persistence intervals to use to compute coordinates. If less than out_dim suitable intervals are found, the construction will show a warning and construct CircularCoordinates with a lower out_dim. This warning can be suppressed by passing warn=false.\npartition: a function that defines the partition of unity used when determining the coordinates. Should take two arguments, r, the radius of the balls, and d, the distance from the landmark. The partition function should only have support on the ball around the landmark (in other words, it should evaluate to 0 when d ≥ r). If that is not the case, the circular coordinates are not well-defined and the results may not always make sense. See Partition for a small collection of predefined functions.\nmetric: a metric from Distances.jl. Can only be set if the filtration argument is Rips.\nkwargs...: additional keyword arguments passed to ripserer. Note that modulus is set to a random prime between 7 and 79 by default.\n\nExample\n\njulia> data = [(sin(t), cos(t)) for t in range(0, 2π, length=101)[1:end-1]];\n\njulia> cc = CircularCoordinates(data, 1:10:100)\nCircularCoordinates(\n  out_dim=1,\n  radius=(0.9510565162951535,),\n  n_landmarks=10,\n  partition=linear,\n  metric=Distances.Euclidean(0.0),\n)\n\njulia> summary(cc(data))\n\"100×1 Matrix{Union{Missing, Float64}}\"\n\njulia> summary(cc(data, 1))\n\"100-element Vector{Union{Missing, Float64}}\"\n\n\nReference\n\nPerea, J. A. (2020, June). Sparse circular coordinates via principal Z-bundles. In Topological Data Analysis: The Abel Symposium 2018 (Vol. 15, p. 435). Springer Nature.\n\n\n\n\n\n","category":"type"},{"location":"api/#Abstract-Types-and-Interfaces","page":"API","title":"Abstract Types and Interfaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AbstractFiltration","category":"page"},{"location":"api/#Ripserer.AbstractFiltration","page":"API","title":"Ripserer.AbstractFiltration","text":"AbstractFiltration{I,T}\n\nA filtration is used to find the edges in filtration and to create simplices. An AbstractFiltration{I,T}'s simplex type is expected to return simplices of type <:AbstractCell{_,T,I}.\n\nAn AbstractFiltration constructor must accept the verbose keyword argument.\n\nInterface\n\nnv(::AbstractFiltration)\nbirths(::AbstractFiltration)\nvertices(::AbstractFiltration)\nedges(::AbstractFiltration)\nsimplex_type(::Type{AbstractFiltration}, dim)\nsimplex(::AbstractFiltration, ::Val{dim}, vertices)\nunsafe_simplex(::AbstractFiltration, ::Val{dim}, vertices)\nunsafe_cofacet(::AbstractFiltration, simplex, vertices, vertex[, edges])\nthreshold(::AbstractFiltration)\ncolumns_to_reduce(::AbstractFiltration, ::Any)\nemergent_pairs(::AbstractFiltration)\npostprocess_diagram(::AbstractFiltration, ::Any)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.nv(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#Graphs.nv-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"Graphs.nv","text":"nv(::AbstractFiltration)\n\nReturn the number of vertices in filtration.\n\nExample\n\njulia> Ripserer.nv(Rips([1 1; 1 1]))\n2\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.births(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#Ripserer.births-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"Ripserer.births","text":"births(::AbstractFiltration)\n\nGet the birth times of vertices in filtration. Defaults to all births being 0. Must return array of the same shape as the filtration's vertices.\n\nExamples\n\njulia> flt = Rips([1 1 2; 1 0 1; 2 1 0]);\n\njulia> Ripserer.births(flt)\n3-element view(::Vector{Int64}, 1:4:9) with eltype Int64:\n 1\n 0\n 0\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.vertices(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#Graphs.vertices-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"Graphs.vertices","text":"vertices(::AbstractFiltration)\n\nReturn the vertices in filtration. Defaults to 1:n. The shape and eltype of the result can be anything as long as result[result[i]] == result[i] holds.\n\nExample\n\njulia> vertices(Rips([0 1 1; 1 0 1; 1 1 0]))\nBase.OneTo(3)\n\njulia> vertices(Cubical([0 1 1; 1 0 1; 1 1 0]))\n3×3 CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)\n CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)\n CartesianIndex(3, 1)  CartesianIndex(3, 2)  CartesianIndex(3, 3)\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.edges(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#Graphs.edges-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"Graphs.edges","text":"edges(::AbstractFiltration)\n\nGet edges (1-simplices) in filtration. Edges should be of type simplex_type(filtration, 1).\n\nExample\n\njulia> Ripserer.edges(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2))\n3-element Array{Simplex{1,Int64,Int64},1}:\n +Simplex{1}([2, 1], 2)\n +Simplex{1}([3, 1], 1)\n +Simplex{1}([3, 2], 1)\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.simplex_type","category":"page"},{"location":"api/#Ripserer.simplex_type","page":"API","title":"Ripserer.simplex_type","text":"simplex_type(::Type{<:AbstractFiltration}, D)\nsimplex_type(::AbstractFiltration, D)\n\nReturn the D-dimensional simplex type in the filtration. Only the method for the type needs to be overloaded.\n\nExamples\n\njulia> Ripserer.simplex_type(Rips{Int,Float64}, 1)\nSimplex{1, Float64, Int64}\n\njulia> Ripserer.simplex_type(Cubical{2,Float16}, 2)\nCube{2, Float16, 2}\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.simplex","category":"page"},{"location":"api/#Ripserer.simplex","page":"API","title":"Ripserer.simplex","text":" simplex(::AbstractFiltration, ::Val{D}, vertices)\n\nReturn D-simplex constructed from vertices. Return nothing if simplex is not in filtration. This function is safe to call with vertices that are out of order. Default implementation sorts vertices and calls unsafe_simplex.\n\nExample\n\njulia> simplex(Rips([0 2 1; 2 0 1; 1 1 0], threshold=2), Val(1), (1, 2))\n1-dimensional Simplex(index=1, birth=2):\n  +[2, 1]\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.unsafe_simplex","category":"page"},{"location":"api/#Ripserer.unsafe_simplex","page":"API","title":"Ripserer.unsafe_simplex","text":"unsafe_simplex(::AbstractFiltration, ::Val{D}, vertices)\n\nReturn D-simplex constructed from vertices. Return nothing if simplex is not in filtration. The unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.unsafe_cofacet","category":"page"},{"location":"api/#Ripserer.unsafe_cofacet","page":"API","title":"Ripserer.unsafe_cofacet","text":"unsafe_cofacet(filtration, simplex, cofacet_vertices, v[, edges])\nunsafe_cofacet(::Type{S}, filtration, simplex, cofacet_vertices, v[, edges])\n\nReturn cofacet of simplex with vertices equal to cofacet_vertices. v is the vertex that was added to construct the cofacet. In the case of sparse rips filtrations, an additional argument edges is used. edges is a vector that contains the weights on edges connecting the new vertex to old vertices. S is the simplex type which can be used for dispatch.\n\nThe unsafe in the name implies that it's up to the caller to ensure vertices are sorted and unique.\n\nDefault implementation uses unsafe_simplex.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.threshold(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#PersistenceDiagrams.threshold-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"PersistenceDiagrams.threshold","text":"threshold(::AbstractFiltration)\n\nGet the threshold of filtration. This is the maximum diameter a simplex in the filtration can have. Defaults to Inf.\n\nExamples\n\njulia> threshold(Rips([0 2 1; 2 0 1; 1 1 0]))\n1\n\njulia> threshold(Cubical([1 1 2; 3 2 1; 0 0 0]))\n3\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.columns_to_reduce","category":"page"},{"location":"api/#Ripserer.columns_to_reduce","page":"API","title":"Ripserer.columns_to_reduce","text":"columns_to_reduce(::AbstractFilration, prev_column_itr)\n\nList all columns to reduce in next dimension, possibly computing it from previous columns. Default implementation uses coboundary with the all cofacets parameter set to Val(false).\n\nExample\n\njulia> flt = Rips([0 1 1; 1 0 1; 1 1 0]);\n\njulia> Ripserer.columns_to_reduce(flt, Ripserer.edges(flt)) |> collect\n1-element Vector{Simplex{2, Int64, Int64}}:\n +Simplex{2}((3, 2, 1), 1)\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.emergent_pairs","category":"page"},{"location":"api/#Ripserer.emergent_pairs","page":"API","title":"Ripserer.emergent_pairs","text":"emergent_pairs(::AbstractFiltration)\n\nReturn true if the emergent pairs optimization is to be performed. Default to returning true. Should be set to false for a filtration type that is unable to produce (co)boundary simplices in the correct order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.postprocess_diagram","category":"page"},{"location":"api/#Ripserer.postprocess_diagram","page":"API","title":"Ripserer.postprocess_diagram","text":"postprocess_diagram(::AbstractFiltration, diagram)\n\nThis function is called on each resulting persistence diagram after all intervals have been computed. Defaults to not doing anything.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.distance_matrix","category":"page"},{"location":"api/#Ripserer.distance_matrix","page":"API","title":"Ripserer.distance_matrix","text":"distance_matrix(::AbstractFiltration)\n\nReturn a matrix with distances between vertices of the filtration. These distances are used to determine edge length when finding shortest represenatative cycle in reconstruct_cycle.\n\nDefaults to all distances being 1.\n\nExamples\n\njulia> flt = Rips([1 1 2; 1 0 1; 2 1 0]);\n\njulia> Ripserer.distance_matrix(flt)\n3×3 Matrix{Int64}:\n 1  1  2\n 1  0  1\n 2  1  0\n\njulia> flt = Custom([(1,2,3,4) => 10.0, (1,2) => 3.0, (1,3) => 4.0, (2,3) => 5.0]);\n\njulia> Ripserer.distance_matrix(flt)\n4×4 Ripserer.DefaultDist{Float64}:\n 0.0  1.0  1.0  1.0\n 1.0  0.0  1.0  1.0\n 1.0  1.0  0.0  1.0\n 1.0  1.0  1.0  0.0\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AbstractRipsFiltration","category":"page"},{"location":"api/#Ripserer.AbstractRipsFiltration","page":"API","title":"Ripserer.AbstractRipsFiltration","text":"AbstractRipsFiltration{I<:Signed, T} <: AbstractFiltration{I, T}\n\nAn abstract Vietoris-Rips filtration. Its subtypes can only overload adjacency_matrix and get default implementations for the rest of the filtration interface.\n\nExample\n\njulia> struct MyRips <: Ripserer.AbstractRipsFiltration{Int, Float16} end\n\njulia> Ripserer.adjacency_matrix(::MyRips) = [0 1 1; 1 0 1; 1 1 0]\n\njulia> ripserer(MyRips())\n2-element Vector{PersistenceDiagrams.PersistenceDiagram}:\n 3-element 0-dimensional PersistenceDiagram\n 0-element 1-dimensional PersistenceDiagram\n\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.adjacency_matrix(::Ripserer.AbstractFiltration)","category":"page"},{"location":"api/#Graphs.LinAlg.adjacency_matrix-Tuple{Ripserer.AbstractFiltration}","page":"API","title":"Graphs.LinAlg.adjacency_matrix","text":"adjacency_matrix(::AbstractFiltration)\n\nReturn the adjacency matrix. For sparse filtrations, this should return a SparseMatrixCSC.\n\nExamples\n\njulia> Ripserer.adjacency_matrix(Rips([0 2 1; 2 0 1; 1 1 0]))\n3×3 Matrix{Int64}:\n 0  2  1\n 2  0  1\n 1  1  0\n\njulia> Ripserer.adjacency_matrix(Rips([0 10 2; 10 0 1; 2 1 0]; sparse=true))\n3×3 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n ⋅  ⋅  2\n ⋅  ⋅  1\n 2  1  ⋅\n\njulia> Ripserer.adjacency_matrix(Custom([(2, 1) => 1, (5, 1) => 2, (3, 4) => 3]))\n5×5 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:\n ⋅  1  ⋅  ⋅  1\n 1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  1  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AbstractCustomFiltration","category":"page"},{"location":"api/#Ripserer.AbstractCustomFiltration","page":"API","title":"Ripserer.AbstractCustomFiltration","text":"abstract type AbstractCustomFiltration{I, T} <: AbstractFiltration{I, T}\n\nThis abstract type is for filtrations that have all simplices stored in Dicts. The dicts should be accessible by the function simplex_dicts and should be a vector of Dict{I, T}. A custom filtration should also have adjacency_matrix defined. This matrix is only used as an adjacency matrix. Its values are ignored.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.simplex_dicts","category":"page"},{"location":"api/#Ripserer.simplex_dicts","page":"API","title":"Ripserer.simplex_dicts","text":"simplex_dicts(::AbstractCustomFiltration)\n\nGet the dictionaries used to get simplex birth times. Should return a Vector of Dict{I, T} that maps a simplex index to its birth time. The first element of this Vector corresponds to vertices, second to 1-simplices etc.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AbstractCell","category":"page"},{"location":"api/#Ripserer.AbstractCell","page":"API","title":"Ripserer.AbstractCell","text":"AbstractCell{D, T, I}\n\nAn abstract type for representing simplices and other types of cells, such as cubes. A cell is determined by the following.\n\nIts dimension encoded in the type parameter D. Can be accessed with dim\nThe index of type I is used to differentiate between different cells. In general, two cells of the same type (and hence dimension) and the same index are considered to be equal.\nThe birth of type T determines when the cell enters the filtration. Note that two cells with the same index should also have the same birth.\nvertices should return the cell's vertices as a tuple. For 0-cells (vertices), the vertices are also used to index into a filtration's vertices.\nThe sign determens its orientation. Note that cell == -cell.\n\nInterface\n\nbirth(::AbstractCell)::T\nindex(::AbstractCell)::I\nvertices(σ::AbstractCell)::NTuple{length(σ),I}\nlength(::Type{AbstractCell})\nsign(::AbstractCell)\nBase.:-(::AbstractCell)\ncoboundary(::Any, ::AbstractCell)\nboundary(::Any, ::AbstractCell)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ripserer.AbstractSimplex","category":"page"},{"location":"api/#Ripserer.AbstractSimplex","page":"API","title":"Ripserer.AbstractSimplex","text":"AbstractSimplex{D, T, I<:Integer} <: AbstractCell{I}\n\nAn abstract type for representing simplices. A simplex is an AbstractCell with an integer index. A D-simplex has D + 1 vertices.\n\nIf a type implements the interface below, default implementations of boundary, coboundary, and vertices are provided.\n\nInterface\n\nAbstractSimplex{0}(::I, ::T)\nAbstractSimplex{1}(::I, ::T)\nbirth(::AbstractSimplex)\nindex(::AbstractSimplex)\nsign(::AbstractSimplex)\nBase.:-(::AbstractSimplex)\nunsafe_simplex\nunsafe_cofacet\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Base.sign(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#Base.sign-Tuple{Ripserer.AbstractCell}","page":"API","title":"Base.sign","text":"sign(σ::AbstractCell)\n\nGet the orientation of σ. Should return -1 or 1.\n\nExamples\n\njulia> sign(Simplex{2}((3, 2, 1), 3.2))\n1\n\njulia> sign(-Simplex{2}((3, 2, 1), 3.2))\n-1\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Base.:-(::Ripserer.AbstractCell)","category":"page"},{"location":"api/#Base.:--Tuple{Ripserer.AbstractCell}","page":"API","title":"Base.:-","text":"-(σ::AbstractCell)\n\nReverse the cell orientation.\n\nExample\n\njulia> -Simplex{2}((3, 2, 1), 3.2)\n2-dimensional Simplex(index=1, birth=3.2):\n  -(3, 2, 1)\n\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Ripserer.coboundary","category":"page"},{"location":"api/#Ripserer.coboundary","page":"API","title":"Ripserer.coboundary","text":"coboundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the coboundary of simplex by decreasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nIf all_cofacets is false, only return cofaces with vertices added to the beginning of vertex list. The method with all_cofacets only has to be implemented if the filtration does not overload columns_to_reduce.\n\nComes with a default implementation.\n\nwarning: Warning\nIf cofacets are not returned in decreasing index order, the algorithm will not work correctly. If there is no avoiding it, define emergent_pairs(...) = false for your filtration.\n\nExamples\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor c in Ripserer.coboundary(filtration, Simplex{1}(2, 1))\n    println(c)\nend\n\n# output\n\n+Simplex{2}((4, 3, 1), 1)\n-Simplex{2}((3, 2, 1), 1)\n\nfor c in Ripserer.coboundary(filtration, Simplex{1}(2, 1), Val(false))\n    println(c)\nend\n\n# output\n\n+Simplex{2}((4, 3, 1), 1)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Ripserer.boundary","category":"page"},{"location":"api/#Ripserer.boundary","page":"API","title":"Ripserer.boundary","text":"boundary(filtration, simplex[, Val{all_cofacets}])\n\nIterate over the boundary of simplex by increasing index. Use the filtration to determine the diameters and validity of cofacets.\n\nComes with a default implementation.\n\nwarning: Warning\nIf facets are not returned in increasing index order, the (homology) algorithm will not work correctly. If there is no avoiding it, define emergent_pairs(...) = false for your filtration.\n\nExample\n\nfiltration = Rips([0 1 1 1; 1 0 1 1; 1 1 0 1; 1 1 1 0])\n\nfor f in Ripserer.boundary(filtration, Simplex{2}(2, 1))\n    println(f)\nend\n\n# output\n\n+Simplex{1}((2, 1), 1)\n-Simplex{1}((4, 1), 1)\n+Simplex{1}((4, 2), 1)\n\n\n\n\n\n","category":"function"},{"location":"references/#Acknowledgments","page":"Acknowledgements and References","title":"Acknowledgments","text":"","category":"section"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"I would like to thank:","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"@ubauer for creating the original Ripser on which this project is based.\n@ctralie and @sauln for creating ripser.py which has been a source of inspiration.\nŽiga Virk, for giving ideas and helping with the theoretical side of things.","category":"page"},{"location":"references/#References","page":"Acknowledgements and References","title":"References","text":"","category":"section"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Bauer, U. (2019). Ripser: efficient computation of Vietoris-Rips persistence barcodes. arXiv preprint arXiv:1908.02518.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Kaji, S., Sudo, T., & Ahara, K. (2020). Cubical Ripser: Software for computing persistent homology of image and volume data. arXiv preprint arXiv:2005.12692.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Wagner, H., Chen, C., & Vuçini, E. (2012). Efficient computation of persistent homology for cubical data. In Topological methods in data analysis and visualization II (pp. 91-106). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Chen, C., & Kerber, M. (2011, March). Persistent homology computation with a twist. In Proceedings 27th European Workshop on Computational Geometry (Vol. 11, pp. 197-200).","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"De Silva, V., Morozov, D., & Vejdemo-Johansson, M. (2011). Persistent cohomology and circular coordinates. Discrete & Computational Geometry, 45(4), 737-759.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Zomorodian, A., & Carlsson, G. (2005). Computing persistent homology. Discrete & Computational Geometry, 33(2), 249-274.","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Edelsbrunner, H. (1993, July). The union of balls and its dual shape. In Proceedings of the ninth annual symposium on Computational geometry (pp. 218-231).","category":"page"},{"location":"references/","page":"Acknowledgements and References","title":"Acknowledgements and References","text":"Čufar, M. & Virk, Ž. (2021). Fast computation of persistent homology representatives with involuted persistent homology. arXiv preprint arxiv:2105.03629","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/cubical.jl\"","category":"page"},{"location":"generated/cubical/#Cubical-Persistent-Homology","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"In this example, we will demonstrate computing sublevel set persistent homology of time series and image data. We will need the following packages.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"using Ripserer\nusing Images\nusing Plots\ngr() # hide\nusing Random # hide\nRandom.seed!(1337) # hide\nnothing # hide","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We will use two data sets in this example. The first will be a curve:","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"n = 1000\nx = range(0, 1; length=n)\ncurve = sin.(2π * 5x) .* x\n\ncurve_plot = plot(curve; legend=false, title=\"Curve\")","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The other will be the Event Horizon Telescope picture of a black hole. We will use a small, 240×240 pixel version of the image. Ripserer should have no problems with processing larger images, but this will work well enough for this tutorial.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"blackhole_image = load(\n    joinpath(@__DIR__, \"../assets/data/240px-Black_hole_-_Messier_87_crop_max_res.jpg\")\n)\nblackhole_plot = plot(blackhole_image; title=\"Black Hole\")","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To use the image with Ripserer, we have to convert it to grayscale.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"blackhole = Gray.(blackhole_image)\nnothing # hide","category":"page"},{"location":"generated/cubical/#One-dimensional-Case","page":"Cubical Persistent Homology","title":"One-dimensional Case","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Sublevel set persistent homology provides a stable description of the critical points of a function. The zeroth persistent homology group H_0 corresponds to its local minima. To compute this with Ripserer, we use cubical persistent homology. Note that there is no information in H_1, since the function is one-dimensional, so we only grab the first part of the result.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result, _ = ripserer(Cubical(curve))\nplot(curve_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To see which minimum each interval corresponds to, we compute representatives by setting reps=true.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result, _ = ripserer(Cubical(curve); reps=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The infinite interval's representative will include the whole function. To plot a representative, simply pass the interval along with the data to plot. An alternative way to plot the same thing is to get the representative of the interval first and then plot that in the same way. Let's use both ways in the following example.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"infinite_interval = only(filter(!isfinite, result))\nplt = plot(\n    representative(infinite_interval),\n    curve;\n    legend=false,\n    title=\"Representatives\",\n    seriestype=:path,\n)\n\nfor interval in filter(isfinite, result)\n    plot!(plt, interval, curve; seriestype=:path)\nend","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"To get the locations of the minima, extract the critical simplices from intervals. Since simplices act like collections of vertex indices, and zero-dimensional representatives have a single point each, we can use only to extract them. Cubical simplices store vertices as CartesianIndex, so we need to index into the x-values with them to plot them.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"min_indices = [only(birth_simplex(int)) for int in result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(plt, min_x, curve[min_x]; color=1:6, markershape=:star)\nplot(plt, plot(result; markercolor=1:6, markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Note that each interval's birth is equal to the value of the corresponding local minimum and its death is equal to the higher of the two adjacent maxima. An intuitive way of thinking about the result is imagining you pour water in the curve. Water is collected in a valley and once it reaches a local maximum, it starts pouring in the adjacent valley.","category":"page"},{"location":"generated/cubical/#Dealing-With-Noise","page":"Cubical Persistent Homology","title":"Dealing With Noise","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Let's add some noise to the curve from earlier and try to repeat the example.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"noisy_curve = curve .+ rand(length(curve))\nplot(noisy_curve)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Compute the persistence diagram and plot it. The persistence argument to plot plots the diagram in birth, persistence coordinates, which will make the level of noise easier to see.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"noisy_result, _ = ripserer(Cubical(noisy_curve); reps=true)\nplot(noisy_result; persistence=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We can see a lot of noise in the diagram, but notice how all of it is below 1, which is exactly the amount we added. We can filter this out by supplying the cutoff argument to ripserer. This will ignore all intervals below this cutoff.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"filtered_result, _ = ripserer(Cubical(noisy_curve); reps=true, cutoff=1)\nplot(filtered_result; persistence=true)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We could achieve the same result by simply filtering the resulting diagram.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"@assert filter(int -> persistence(int) > 1, noisy_result) == filtered_result # hide\nfilter(int -> persistence(int) > 1, noisy_result) == filtered_result","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Keep in mind, however, that for very large diagrams, collecting representatives on all of the noise could make ripserer much run slower. In that case, it is recommended to use cutoff, rather than filtering.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Now we can repeat what we did earlier.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"infinite_interval = only(filter(!isfinite, filtered_result))\nplt = plot(\n    representative(infinite_interval),\n    noisy_curve;\n    legend=false,\n    title=\"Representatives\",\n    seriestype=:path,\n)\n\nfor interval in sort(filter(isfinite, filtered_result); by=birth)\n    plot!(plt, interval, noisy_curve; seriestype=:path)\nend\n\nmin_indices = [first(birth_simplex(int)) for int in filtered_result]\nmin_x = eachindex(curve)[min_indices]\n\nscatter!(\n    plt, min_x, noisy_curve[min_x]; color=eachindex(filtered_result), markershape=:star\n)\nplot(plt, plot(filtered_result; markercolor=eachindex(filtered_result), markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"The result we got is very similar even though the data set was very noisy.","category":"page"},{"location":"generated/cubical/#Two-dimensional-Case","page":"Cubical Persistent Homology","title":"Two-dimensional Case","text":"","category":"section"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Now let's do a similar thing for a 2d example. Nothing is stopping us from going into higher dimensions, but we will skip those. The principles are the same. Instead of looking for local minima, let's look for local maxima. To do that, we have to invert the image.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole))\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We notice there are quite a lot of intervals along the diagonal. These correspond to the local geometry of the image, so we are not interested in them right now. To filter them out, we set a cutoff.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole); cutoff=0.1)\nplot(blackhole_plot, plot(result))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Like earlier, we can show the local extrema in the image. We will show a different way to plot them. Let's use the threshold argument with plot, which only keeps parts of the representative with a diameter equal to or lower than threshold. If we needed a strict <, we could use threshold_strict.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole); cutoff=0.1, reps=true)\nplt = plot(blackhole_image; title=\"Black Hole\")\nfor interval in result[1]\n    plot!(plt, interval, blackhole; threshold=birth(interval))\nend\nplot(plt, plot(result[1]; markercolor=2:3, markeralpha=1))","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Some maxima have multiple values because more than one pixel in the image has the same value. Using birth_simplex instead of plotting the filtered representative would only show one of each.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Unlike in the previous example, we now also have access to H_1, which corresponds to the cycles in the image. Let's try to plot the representative of H_1.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"plt = plot(blackhole_image; title=\"Black Hole\")\nplot!(plt, only(result[2]), blackhole; label=\"H₁ cocycle\", color=1)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"Notice that the result is not a cycle, but rather a collection of pixels that would destroy the cycle if removed. The reason is that Ripserer computes persistent cohomology by default. The persistence diagrams of persistent homology and persistent cohomology are the same, but persistent cohomology is much more efficient to compute. The representatives it finds, however, tend to not be as informative. Keep this in mind when trying persistent homology out for larger datasets; it can take a very very long time. This case is quite small and computing persistent homology should pose no problem. We compute persistent homology with the argument alg=:homology.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"warning: Infinite Intervals in Persistent Homology\nRipserer currently can't compute infinite intervals in dimensions higher than zero with persistent homology.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"result = ripserer(Cubical(-blackhole); cutoff=0.1, reps=true, alg=:homology)\nplot!(plt, only(result[2]), blackhole; label=\"H₁ cycle\", color=3)","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"We have successfully found the hole in a black hole.","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"","category":"page"},{"location":"generated/cubical/","page":"Cubical Persistent Homology","title":"Cubical Persistent Homology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/malaria.jl\"","category":"page"},{"location":"generated/malaria/#Image-Classification-With-Cubical-Persistent-Homology","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"In this example, we will show how to use Ripserer in an image classification context. Persistent homology is not a predictive algorithm, but it can be used to extract useful features from data.","category":"page"},{"location":"generated/malaria/#Setting-up","page":"Image Classification With Cubical Persistent Homology","title":"Setting up","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"using Ripserer\nusing PersistenceDiagrams\nusing Images # also required: ImageIO to read .png files\nusing Plots\nusing ProgressMeter\nusing Random\nRandom.seed!(1337)\n\ndata_dir = joinpath(@__DIR__, \"../assets/data/malaria\") # replace with the correct path.\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Let's load the data. We will use a a data set with microscope images of healthy cells and cells infected with malaria. The original data set is quite large, but we can pretend we were only given 200 images to work with. We have chosen the 200 images randomly.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"uninfected = shuffle!(Images.load.(readdir(joinpath(data_dir, \"uninfected\"); join=true)))\ninfected = shuffle!(Images.load.(readdir(joinpath(data_dir, \"infected\"); join=true)))\n\nimages = [uninfected; infected]\nclasses = [fill(false, length(uninfected)); fill(true, length(infected))]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Let's see what the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(\n    plot(uninfected[1]; title=\"Healthy\"),\n    plot(uninfected[2]; title=\"Healthy\"),\n    plot(infected[1]; title=\"Infected\"),\n    plot(infected[2]; title=\"Infected\"),\n)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"To make the images work with Ripserer, we convert them to floating gray scale values. We do not have to resize the images. Maybe some additional preprocessing, such as normalization would help, but we'll skip it for this example.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"inputs = [Gray.(image) for image in images]\nnothing # hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Now we can compute persistence diagrams. Since we are working with images, we have to use the Cubical filtration type. Cubical persistent homology should detect the dark spots (local minima) in the images. It's pretty efficient, so this should only take a few seconds.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"diagrams = @showprogress [ripserer(Cubical(i)) for i in inputs]","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"This is what some of the diagrams look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(plot(images[1]; title=\"Healthy\"), plot(diagrams[1]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(plot(images[end]; title=\"Infected\"), plot(diagrams[end]))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Notice that there is a lot more going on in the middle of the infected diagram, especially in H_0.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"The persistence diagrams might look nice, but are hard to use with machine learning algorithms. The number of points in the diagram may be different for every image, even when images are of the same size. We can solve this problem by using a vectorization method, such as converting all diagrams to persistence images.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Persistence images work by weighting each point in the diagram with a distribution. The distribution defaults to a Gaussian, but any function of two arguments can be used. Each point is also weighted by a weighting function that should be equal to zero along the x-axis. It defaults to a function that is zero on the x-axis and linearly increases to the maximum persistence in the diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"We start by splitting the diagrams into their 0 and 1 dimensional components.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"dim_0 = first.(diagrams)\ndim_1 = last.(diagrams)\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"We feed the diagram to the PersistenceImage constructor which will choose ranges that will fit all the diagrams. We set the sigma value to 0.1, since all persistence pairs are in the 0101 square and the default sigma of 1 would be too wide. We will use the default image size, which is 5×5.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"image_0 = PersistenceImage(dim_0; sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"image_1 = PersistenceImage(dim_1; sigma=0.1)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Let's see how some of the images look like.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(plot(dim_0[end]; persistence=true), heatmap(image_0(dim_0[end]); aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(plot(dim_1[end]; persistence=true), heatmap(image_1(dim_1[end]); aspect_ratio=1))","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Next, we convert all diagrams to images and use vec to turn them into flat vectors. We then concatenate the zero and one-dimensional images. The result is a vector of length 50 for each diagram.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"persims = [[vec(image_0(dim_0[i])); vec(image_1(dim_1[i]))] for i in 1:length(diagrams)]","category":"page"},{"location":"generated/malaria/#Fitting-A-Model","page":"Image Classification With Cubical Persistent Homology","title":"Fitting A Model","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Now it's time to fit our model. We will use GLMNet.jl to fit a regularized linear model.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"using GLMNet","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Convert the image vectors to a matrix that will be understood by glmnet.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"X = reduce(hcat, persims)'\ny = classes\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Start by randomly splitting the data into two sets, a training and a testing set.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"perm = shuffle(1:200)\ntrain_x = X[perm[1:100], :]\ntrain_y = y[perm[1:100]]\ntest_x = X[perm[101:end], :]\ntest_y = y[perm[101:end]]\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Fit the model and predict.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"path = glmnet(train_x, train_y)\ncv = glmnetcv(train_x, train_y)\n\nλ = path.lambda[argmin(cv.meanloss)]\npath = glmnet(train_x, train_y; lambda=[λ])\n\npredictions = .!iszero.(round.(GLMNet.predict(path, test_x)))\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Get the classification accuracy.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"count(predictions .== test_y) / length(test_y)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Not half bad considering we haven't touched the images and we left pretty much all settings on default.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Now let's look at the misclassified examples.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"missed = findall(predictions .!= test_y)\nlabel = (\"Healthy\", \"Infected\")\nplts = [plot(images[i]; title=\"$(label[test_y[i] + 1])\", ticks=nothing) for i in missed]\nplot(plts...)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Finally, let's look at which parts of the persistence images glmnet considered important.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"plot(\n    heatmap(reshape(path.betas[1:25], (5, 5)); title=\"H₀ coefficients\"),\n    heatmap(reshape(path.betas[26:50], (5, 5)); title=\"H₁ coefficients\"),\n)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"These correspond to the area we identified at the beginning. Also note that in this case, the classifier does not care about H_1 at all.","category":"page"},{"location":"generated/malaria/#Using-MLJ","page":"Image Classification With Cubical Persistent Homology","title":"Using MLJ","text":"","category":"section"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Another, more straightforward way to execute a similar pipeline is to use Ripserer's MLJ.jl integration. We will use a random forest classifier for this example.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"We start by loading MLJ and the classifier. Not that MLJDecisionTreeInterface.jl needs to be installed for this to work.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"using MLJ\ntree = @load RandomForestClassifier pkg = \"DecisionTree\" verbosity = 0","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"We create a pipeline of CubicalPersistentHomology followed by the classifier. In this case, CubicalPersistentHomology takes care of both the homology computation and the conversion to persistence images.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"pipe = @pipeline(CubicalPersistentHomology(), tree)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"We train the pipeline the same way you would fit any other MLJ model. Remember, we need to use grayscale versions of images stored in inputs.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"classes = coerce(classes, Binary)\ntrain, test = partition(eachindex(classes), 0.7; shuffle=true, rng=1337)\nmach = machine(pipe, inputs, classes)\nfit!(mach; rows=train)","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"Next, we predict the classes on the test data and print out the classification accuracy.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"yhat = predict_mode(mach, inputs[test])\naccuracy(yhat, classes[test])","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"The result is quite a bit worse than before. We can try mitigating that by using a different vectorizer.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"pipe.cubical_persistent_homology.vectorizer = PersistenceCurveVectorizer()\nmach = machine(pipe, inputs, classes)\nfit!(mach; rows=train)\n\nyhat = predict_mode(mach, inputs[test])\naccuracy(yhat, classes[test])","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"The result could be improved further by choosing a different model and vectorizer. However, this is just a short introduction. Please see the MLJ.jl documentation for more information on model tuning and selection, and the PersistenceDiagrams.jl documentation for a list of vectorizers and their options.","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"","category":"page"},{"location":"generated/malaria/","page":"Image Classification With Cubical Persistent Homology","title":"Image Classification With Cubical Persistent Homology","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/stability.jl\"","category":"page"},{"location":"generated/stability/#Stability","page":"Stability","title":"Stability","text":"","category":"section"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"In this example, we will demonstrate the stability of persistent homology. The stability theorem roughly states that a small change in the input data will result in a small change in the resulting persistence diagram. In other words, persistent homology is very tolerant of noisy data. Also, see the Distances example in PersistenceDiagrams.jl.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, start with loading some packages.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"using Ripserer\nusing Plots\nusing Random; # hide\nRandom.seed!(1337); # hide\ngr(); # hide\nnothing; # hide\nnothing #hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"As in the Basics example, we will look at the persistent homology of a noisy circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"function noisy_circle(n; r1=1, r2=1, noise=0.1)\n    points = NTuple{2,Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        point = (\n            r1 * sin(θ) + noise * rand() - noise / 2,\n            r2 * cos(θ) + noise * rand() - noise / 2,\n        )\n        push!(points, point)\n    end\n    return points\nend","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We will look at the first persistent homology group of this space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"First, let's see what happens if we repeatedly sample 100 random points from a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100; noise=0)\n    result = ripserer(points)\n\n    plt_pts = scatter(\n        points;\n        legend=false,\n        aspect_ratio=1,\n        xlim=(-2.2, 2.2),\n        ylim=(-2.2, 2.2),\n        title=\"Data\",\n    )\n    plt_diag = plot(result; infinity=3)\n\n    plot(plt_pts, plt_diag; size=(800, 400))\nend\ngif(anim, \"stability_anim_1.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We notice that an interval in H_1 always stands out and that its death remains constant. The only thing that changes is the birth time. The birth time is equal to the largest distance between adjacent points in the circle. At the birth time, the circle is connected.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Now, let's add some noise!","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for _ in 1:200\n    points = noisy_circle(100; noise=0.2)\n    result = ripserer(points)\n\n    plt_pts = scatter(\n        points;\n        legend=false,\n        aspect_ratio=1,\n        xlim=(-2.2, 2.2),\n        ylim=(-2.2, 2.2),\n        title=\"Data\",\n    )\n    plt_diag = plot(result; infinity=3)\n\n    plot(plt_pts, plt_diag; size=(800, 400))\nend\ngif(anim, \"stability_anim_2.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"The interval is jumping around a lot more now, but it hovers around the same general area. It's still clearly the most persistent feature of our space.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Next, let's look at how adding more and more noise affects the diagram.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for noise in vcat(0:0.01:1, 1:-0.01:0)\n    points = noisy_circle(100; noise=noise)\n    result = ripserer(points)\n\n    plt_pts = scatter(\n        points;\n        legend=false,\n        aspect_ratio=1,\n        xlim=(-2.2, 2.2),\n        ylim=(-2.2, 2.2),\n        title=\"Data\",\n    )\n    plt_diag = plot(result; infinity=3)\n\n    plot(plt_pts, plt_diag; size=(800, 400))\nend\ngif(anim, \"stability_anim_3.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"We see we have to add quite a bit of noise to destroy the diagram. Notice how the death time of the interval decreases as we add noise. This is the result of the diameter of the hole in our circle shrinking.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Finally, let's stretch our circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"anim = @animate for r in vcat(0.0:0.02:2, 2:-0.02:0.0)\n    points = noisy_circle(100; noise=0.1, r1=r)\n    result = ripserer(points)\n\n    plt_pts = scatter(\n        points;\n        legend=false,\n        aspect_ratio=1,\n        xlim=(-2.2, 2.2),\n        ylim=(-2.2, 2.2),\n        title=\"Data\",\n    )\n    plt_diag = plot(result; infinity=3)\n\n    plot(plt_pts, plt_diag; size=(800, 400))\nend\ngif(anim, \"stability_anim_4.gif\") # hide","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"Again, we see the persistent homology stays stable, as long as the data at least somewhat resembles a circle.","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"","category":"page"},{"location":"generated/stability/","page":"Stability","title":"Stability","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Flexible and efficient persistent homology computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Matija Čufar (@mtsch)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is a pure Julia library for computing persistent homology based on the Ripser algorithm. Roughly speaking, persistent homology detects the global topological and local geometric structure of data in a noise-resistant, stable way. If you are unfamiliar with persistent homology, I recommend reading this excellent introduction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please see the Usage Guide for a quick introduction, and the API page for detailed descriptions of Ripserer's functionality.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While this package is fully functional, it is still in development and should not be considered stable. I try to disrupt the public interface as little as possible, but breaking changes might still occur from time to time.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered. To install it, simply run the following and everything should just work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(\"Ripserer\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"All versions of Julia from 1.0 onward are supported, but I recommend using the latest version of Julia for optimal performance.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer and its companion package PersistenceDiagrams.jl currently support","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast Vietoris-Rips and cubical, and alpha complex persistent homology computation.\nRepresentative cocycle, cycle, and critical simplex computation.\nConvenient persistence diagram and representative cocycle visualization via Plots.jl. Experimental Makie.jl is also available here.\nBottleneck and Wasserstein matching and distance computation.\nVarious persistence diagram vectorization functions, implemented with persistence images and persistence curves.\nEasy extensibility through a documented API.\nIntegration with MLJ.jl.\nExperimental shortest representative cycle computation.\nExperimental sparse circular coordinate computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access some of the features, you need to use the PersistenceDiagrams.jl package.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much like Ripser, Ripserer uses several computational tricks to achieve its speed. Among others, these include an implicit simplicial complex representation and the clearing optimization. For a more detailed overview of these optimizations, check out Ulrich Bauer's article on Ripser.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, the performance of Ripserer is very close to Ripser, usually within around 30%. Ripserer's strength performance-wise is very sparse inputs, where it can sometimes outperform Ripser. It also computes some things Ripser skips, like the critical simplices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ripserer's Cubical homology is up to 3× slower than that of Cubical Ripser, which uses a more specialized algorithm. Ripserer is still a good choice for small 3d images and large 2d images. Unlike Cubical Ripser, it also supports computations on images of dimensions higher than 4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Benchmarks section for more detailed benchmarks.","category":"page"},{"location":"#Extending","page":"Home","title":"Extending","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ripserer is designed to be easily extended with new simplex or filtration types. See the Abstract Types and Interfaces API section for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have written an extension or are having trouble implementing one, please feel free to open a pull request or an issue. You may also contact me directly.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All contributions are welcome, even small things like typo fixes and ideas! See the contribution guidelines for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you used this software in a cool project, or if you have any comments, questions, or suggestions, feel free to contact me at matijacufar@gmail.com.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you used Ripserer in your work, consider citing the JOSS paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A bibtex entry is provided in CITATION.bib.","category":"page"},{"location":"related-work/#Related-Julia-Packages","page":"Related Julia Packages","title":"Related Julia Packages","text":"","category":"section"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"This section attempts to provide an overview of Julia packages implementing persistent homology. If you're trying to do something Ripserer is missing, one of these might have what you're looking for.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"This list is incomplete and only includes things I'm aware of. The descriptions are based on my (limited) experience with these packages.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"ComputationalHomology.jl uses a different, slower algorithm, but can do some things Ripserer can't such as Čech persistent homology and homology of CW complexes. The package is a part of TDA.jl, which also offers other topological data analysis tools like Mapper.\nEirene.jl uses a different algorithm based on matroids. A benefit of this algorithm is that it can recover persistent homology generators and a bunch of other data.\nRipser.jl my deprecated wrapper of the original C++ program. Very bare-bones and outdated. Runs a bit slower than Ripserer.\nSparips.jl this is a preprocessor that comes with a different wrapper of Ripser. The preprocessor allows you to compute persistent homology of very large datasets. Integrating it with Ripserer is on my TODO list.\nPersistentCohomology.jl does essentially the same thing, but with a different algorithm, that is orders of magnitude slower.","category":"page"},{"location":"related-work/","page":"Related Julia Packages","title":"Related Julia Packages","text":"If you are a developer of a persistent homology package not on this list, or any of the information here is incorrect, let me know or open a PR.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"EditURL = \"https://github.com/mtsch/Ripserer.jl/blob/master/docs/src/examples/basics.jl\"","category":"page"},{"location":"generated/basics/#Usage-Guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"In this example, we will present the basics of using Ripserer. We start by loading some packages.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"using Distances\nusing Plots\nusing Ripserer\nusing Random # hide\nRandom.seed!(1337) # hide\ngr() # hide\nnothing # hide","category":"page"},{"location":"generated/basics/#Using-Ripserer-With-Point-Cloud-Data","page":"Usage Guide","title":"Using Ripserer With Point Cloud Data","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Let's start with generating some points, randomly sampled from a noisy circle.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"function noisy_circle(n; r=1, noise=0.1)\n    points = NTuple{2,Float64}[]\n    for _ in 1:n\n        θ = 2π * rand()\n        push!(points, (r * sin(θ) + noise * rand(), r * cos(θ) + noise * rand()))\n    end\n    return points\nend\n\ncirc_100 = noisy_circle(100)\nscatter(circ_100; aspect_ratio=1, legend=false, title=\"Noisy Circle\")","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"tip: Point-like data types\nRipserer can interpret various kinds of data as point clouds. The limitation is that the data set should be an AbstractVector with elements with the following properties:all elements are collections numbers;\nall elements have the same length.Examples of element types that work are Tuples, SVectors, and Points.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"To compute the Vietoris-Rips persistent homology of this data set, run the following.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"ripserer(circ_100)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"You can use the dim_max argument to set the maximum dimension persistent homology is computed in.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"result_rips = ripserer(circ_100; dim_max=3)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The result can be plotted as a persistence diagram or as a barcode.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"plot(result_rips)\nbarcode(result_rips)\nplot(plot(result_rips), barcode(result_rips)) # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"We can also plot a single diagram or a subset of all diagrams in the same manner. Keep in mind that the result is just a vector of PersistenceDiagrams. The zero-dimensional diagram is found at index 1.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"plot(result_rips[2])\nbarcode(result_rips[2:end]; linewidth=2)\nplot(plot(result_rips[2]), barcode(result_rips[2:end]; linewidth=2)) # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Plotting can be further customized using the standard attributes from Plots.jl.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"plot(result_rips; markeralpha=1, markershape=:star, color=[:red, :blue, :green, :purple])","category":"page"},{"location":"generated/basics/#Changing-Filtrations","page":"Usage Guide","title":"Changing Filtrations","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"By default, calling ripserer will compute persistent homology with the Rips filtration. To use a different filtration, we have two options.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The first option is to pass the filtration constructor as the first argument. Any keyword arguments the filtration accepts can be passed to ripserer and it will be forwarded to the constructor.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"ripserer(EdgeCollapsedRips, circ_100; threshold=1, dim_max=3, metric=Euclidean())","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The second option is to initialize the filtration object first and use that as an argument to ripserer. This can be useful in cases where constructing the filtration takes a long time.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"collapsed_rips = EdgeCollapsedRips(circ_100; threshold=1, metric=Euclidean())\nripserer(collapsed_rips; dim_max=3)","category":"page"},{"location":"generated/basics/#Distance-Matrix-Inputs","page":"Usage Guide","title":"Distance Matrix Inputs","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"In the previous example, we got our result by passing a collection of points to ripserer. Under the hood, Rips and EdgeCollapsedRips actually work with distance matrices. Let's define a distance matrix of the shortest paths on a regular icosahedron graph.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/83/Icosahedron_graph.svg\" height=\"200\" width=\"200\">","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"icosahedron = [\n    0 1 2 2 1 2 1 1 2 2 1 3\n    1 0 3 2 1 1 2 1 2 1 2 2\n    2 3 0 1 2 2 1 2 1 2 1 1\n    2 2 1 0 3 2 1 1 2 1 2 1\n    1 1 2 3 0 1 2 2 1 2 1 2\n    2 1 2 2 1 0 3 2 1 1 2 1\n    1 2 1 1 2 3 0 1 2 2 1 2\n    1 1 2 1 2 2 1 0 3 1 2 2\n    2 2 1 2 1 1 2 3 0 2 1 1\n    2 1 2 1 2 1 2 1 2 0 3 1\n    1 2 1 2 1 2 1 2 1 3 0 2\n    3 2 1 1 2 1 2 2 1 1 2 0\n]\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"To compute the persistent homology, simply feed the distance matrix to ripserer.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"result_icosa = ripserer(icosahedron; dim_max=2)","category":"page"},{"location":"generated/basics/#Thresholding","page":"Usage Guide","title":"Thresholding","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"In our next example, we will show how to use thresholding to speed up computation. We start by defining a sampling function that generates n points from the square -44times-44 with a circular hole of radius 1 in the middle.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"function cutout(n)\n    points = NTuple{2,Float64}[]\n    while length(points) < n\n        x, y = (8rand() - 4, 8rand() - 4)\n        if x^2 + y^2 > 1\n            push!(points, (x, y))\n        end\n    end\n    return points\nend","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"We sample 2000 points from this space.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"cutout_2000 = cutout(2000)\nscatter(cutout_2000; markersize=1, aspect_ratio=1, legend=false, title=\"Cutout\")","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"We calculate the persistent homology and time the calculation.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"@time result_cut = ripserer(cutout_2000)\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"plot(result_cut)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Notice that while there are many 1-dimensional classes, one of them stands out. This class represents the hole in the middle of our square. Since the intervals are sorted by persistence, we know the last interval in the diagram will be the most persistent.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"most_persistent = result_cut[2][end]","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Notice the death time of this interval is around 1.83 and that no intervals occur after that time. This means that we could stop computing when we reach this time and the result should not change. Let's try it out.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"@time result_cut_thresh_2 = ripserer(cutout_2000; threshold=2)\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"plot(result_cut_thresh_2; title=\"Persistence Diagram, threshold=2\")","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Indeed, the result is exactly the same, but it took less than a third of the time to compute.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"@assert result_cut_thresh_2 == result_cut # hide\nresult_cut_thresh_2 == result_cut","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"If we pick a threshold that is too low, we still detect the interval, but its death time becomes infinite.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"@time result_cut_thresh_1 = ripserer(cutout_2000; threshold=1)\nnothing # hide","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"result_cut_thresh_1[2][end]","category":"page"},{"location":"generated/basics/#Persistence-Diagrams","page":"Usage Guide","title":"Persistence Diagrams","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The result of a computation is returned as a vector of PersistenceDiagrams. Let's take a closer look at one of those.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"diagram = result_cut[2]","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The diagram is a structure that acts as a vector of PersistenceIntervals. As such, you can use standard Julia functions on the diagram.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"For example, to extract the last three intervals by birth time, you can do something like this.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"sort(diagram; by=birth, rev=true)[1:3]","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"To find the persistences of all the intervals, you can use broadcasting.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"persistence.(diagram)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Unlike regular vectors, a PersistenceDiagram has additional metadata attached to it. To see all metadata, use propertynames.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"propertynames(diagram)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"You can access the properties with the dot syntax.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"diagram.field","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"The attributes dim and threshold are given special treatment and can be extracted with appropriately named functions.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"dim(diagram), threshold(diagram)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Now, let's take a closer look at one of the intervals.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"interval = diagram[end]","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"An interval is very similar to a tuple of two Float64s, but also has some metadata associated with it.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"interval[1], interval[2]","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"birth, death, persistence, and midlife can be used to query commonly used values.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"birth(interval), death(interval), persistence(interval), midlife(interval)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Accessing metadata works in a similar manner as with diagrams.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"propertynames(interval)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"interval.birth_simplex","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"interval.death_simplex","category":"page"},{"location":"generated/basics/#Simplices","page":"Usage Guide","title":"Simplices","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"In the previous section, we saw each interval has an associated birth_simplex and death_simplex. These values are of the type Simplex. Let's take a closer look at simplices.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"simplex = interval.death_simplex","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Simplex is an internal data structure that uses some tricks to increase efficiency. For example, if we were to dump it, we notice the vertices are not actually stored in the simplex itself.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"dump(simplex)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"To access the vertices, we use vertices.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"vertices(simplex)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"Other useful attributes a simplex has are index, dim, and birth.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"index(simplex), dim(simplex), birth(simplex)","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"A few additional notes on simplex properties.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"A D-dimensional simplex is of type Simplex{D} and has D + 1 vertices.\nvertices are always sorted in descending order.\nindex and dim can be used to uniquely identify a given simplex.\nbirth determines when a simplex is added to a filtration.","category":"page"},{"location":"generated/basics/#Conclusion","page":"Usage Guide","title":"Conclusion","text":"","category":"section"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"This concludes the basic usage of Ripserer. For more detailed information, please check out the API page, as well as other examples.","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"","category":"page"},{"location":"generated/basics/","page":"Usage Guide","title":"Usage Guide","text":"This page was generated using Literate.jl.","category":"page"}]
}
